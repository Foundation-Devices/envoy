// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `backup_payload_to_hashmap`, `post_backup_async`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BackupRequest`, `RUNTIME`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `initialize`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChallengeResponse>>
abstract class ChallengeResponse implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< Client>>
abstract class Client implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Response>>
abstract class Response implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StaticSecret>>
abstract class StaticSecret implements RustOpaqueInterface {}

class Backup {
  const Backup();

  static Future<List<(String, String)>> decryptBackup(
          {required List<int> data, required StaticSecret secret}) =>
      RustLib.instance.api
          .crateApiBackupBackupDecryptBackup(data: data, secret: secret);

  static Future<int> delete(
          {required String seedWords,
          required String serverUrl,
          required int proxyPort}) =>
      RustLib.instance.api.crateApiBackupBackupDelete(
          seedWords: seedWords, serverUrl: serverUrl, proxyPort: proxyPort);

  static Future<Response> deleteBackupAsync(
          {required String serverUrl,
          required int proxyPort,
          required String hash}) =>
      RustLib.instance.api.crateApiBackupBackupDeleteBackupAsync(
          serverUrl: serverUrl, proxyPort: proxyPort, hash: hash);

  static Future<Uint8List> encryptBackup(
          {required List<(String, String)> files,
          required StaticSecret secret}) =>
      RustLib.instance.api
          .crateApiBackupBackupEncryptBackup(files: files, secret: secret);

  static Future<List<(String, String)>> extractBackupData(
          {required BackupPayload payload}) =>
      RustLib.instance.api
          .crateApiBackupBackupExtractBackupData(payload: payload);

  static Future<List<(String, String)>> getBackup(
          {required String seedWords,
          required String serverUrl,
          required int proxyPort}) =>
      RustLib.instance.api.crateApiBackupBackupGetBackup(
          seedWords: seedWords, serverUrl: serverUrl, proxyPort: proxyPort);

  static Future<GetBackupResponse> getBackupAsync(
          {required String serverUrl,
          required int proxyPort,
          required String seed}) =>
      RustLib.instance.api.crateApiBackupBackupGetBackupAsync(
          serverUrl: serverUrl, proxyPort: proxyPort, seed: seed);

  static Future<List<(String, String)>> getBackupOffline(
          {required String seedWords, required String filePath}) =>
      RustLib.instance.api.crateApiBackupBackupGetBackupOffline(
          seedWords: seedWords, filePath: filePath);

  static Future<ChallengeResponse?> getChallengeAsync(
          {required String serverUrl, required int proxyPort}) =>
      RustLib.instance.api.crateApiBackupBackupGetChallengeAsync(
          serverUrl: serverUrl, proxyPort: proxyPort);

  static Future<Client> getReqwestClient({required int proxyPort}) =>
      RustLib.instance.api
          .crateApiBackupBackupGetReqwestClient(proxyPort: proxyPort);

  static Future<StaticSecret> getStaticSecret({required String seedWords}) =>
      RustLib.instance.api
          .crateApiBackupBackupGetStaticSecret(seedWords: seedWords);

  static Future<bool> performBackup(
          {required Map<String, String> payload,
          required String seedWords,
          required String serverUrl,
          required String localBackup,
          required int proxyPort,
          required bool performCloud}) =>
      RustLib.instance.api.crateApiBackupBackupPerformBackup(
          payload: payload,
          seedWords: seedWords,
          serverUrl: serverUrl,
          localBackup: localBackup,
          proxyPort: proxyPort,
          performCloud: performCloud);

  static Future<bool> performBackupOffline(
          {required BackupPayload payload,
          required String seedWords,
          required String path}) =>
      RustLib.instance.api.crateApiBackupBackupPerformBackupOffline(
          payload: payload, seedWords: seedWords, path: path);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Backup && runtimeType == other.runtimeType;
}

class BackupPayload {
  final int keysNr;
  final List<String> data;

  const BackupPayload({
    required this.keysNr,
    required this.data,
  });

  @override
  int get hashCode => keysNr.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackupPayload &&
          runtimeType == other.runtimeType &&
          keysNr == other.keysNr &&
          data == other.data;
}

enum GetBackupException {
  serverUnreachable,
  seedNotFound,
  backupNotFound,
  invalidSeed,
  invalidServer,
  invalidBackupFile,
  ;
}

class GetBackupResponse {
  final String backup;

  const GetBackupResponse({
    required this.backup,
  });

  @override
  int get hashCode => backup.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetBackupResponse &&
          runtimeType == other.runtimeType &&
          backup == other.backup;
}
