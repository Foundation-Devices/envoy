// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.24.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';

Future<BtleplugPlatformAdapter?> firstAdapter({dynamic hint}) =>
    RustLib.instance.api.firstAdapter(hint: hint);

Future<List<BtleplugPlatformAdapter>> getAdapters({dynamic hint}) =>
    RustLib.instance.api.getAdapters(hint: hint);

Future<List<BluartPeripheral>> getPeripherals(
        {required BtleplugPlatformAdapter adapter,
        List<String>? tcpPorts,
        dynamic hint}) =>
    RustLib.instance.api
        .getPeripherals(adapter: adapter, tcpPorts: tcpPorts, hint: hint);

Future<void> startScan(
        {required BtleplugPlatformAdapter adapter, dynamic hint}) =>
    RustLib.instance.api.startScan(adapter: adapter, hint: hint);

Future<void> stopScan(
        {required BtleplugPlatformAdapter adapter, dynamic hint}) =>
    RustLib.instance.api.stopScan(adapter: adapter, hint: hint);

Future<void> connectPeripheral(
        {required BluartPeripheral peripheral, dynamic hint}) =>
    RustLib.instance.api.connectPeripheral(peripheral: peripheral, hint: hint);

Future<String> getNameFromPerihperal(
        {required BluartPeripheral peripheral, dynamic hint}) =>
    RustLib.instance.api
        .getNameFromPerihperal(peripheral: peripheral, hint: hint);

Future<bool> isConnected(
        {required BluartPeripheral peripheral, dynamic hint}) =>
    RustLib.instance.api.isConnected(peripheral: peripheral, hint: hint);

Future<void> writeTo(
        {required BluartPeripheral peripheral,
        required UuidValue rxCharacteristic,
        required List<int> data,
        dynamic hint}) =>
    RustLib.instance.api.writeTo(
        peripheral: peripheral,
        rxCharacteristic: rxCharacteristic,
        data: data,
        hint: hint);

Future<Uint8List> readFrom(
        {required BluartPeripheral peripheral,
        required UuidValue characteristic,
        dynamic hint}) =>
    RustLib.instance.api.readFrom(
        peripheral: peripheral, characteristic: characteristic, hint: hint);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<BluartPeripheral>>
@sealed
class BluartPeripheral extends RustOpaque {
  BluartPeripheral.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  BluartPeripheral.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BluartPeripheral,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BluartPeripheral,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_BluartPeripheralPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<TcpAsPeripheral>>
@sealed
class TcpAsPeripheral extends RustOpaque {
  TcpAsPeripheral.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  TcpAsPeripheral.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_TcpAsPeripheral,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_TcpAsPeripheral,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TcpAsPeripheralPtr,
  );

  Future<void> connect({dynamic hint}) =>
      RustLib.instance.api.tcpAsPeripheralConnect(
        that: this,
      );

  static Future<TcpAsPeripheral> newTcpAsPeripheral(
          {required String url, dynamic hint}) =>
      RustLib.instance.api.tcpAsPeripheralNew(url: url, hint: hint);

  Future<void> write({required List<int> data, dynamic hint}) =>
      RustLib.instance.api.tcpAsPeripheralWrite(
        that: this,
        data: data,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<btleplug :: platform :: Adapter>>
@sealed
class BtleplugPlatformAdapter extends RustOpaque {
  BtleplugPlatformAdapter.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  BtleplugPlatformAdapter.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_BtleplugPlatformAdapter,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_BtleplugPlatformAdapter,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_BtleplugPlatformAdapterPtr,
  );
}
