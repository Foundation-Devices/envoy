// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::ql::*;
use crate::api::qr::*;
use bc_xid::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};
use foundation_api::api::quantum_link::*;

// Section: boilerplate

use btp::Dechunker;
use foundation_ur::Decoder;
use std::sync::Mutex;

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 797499272;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_backup_hash_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_get_backup_hash",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.backup_hash.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_get_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.data.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_next_chunk_index_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_get_next_chunk_index",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.next_chunk_index.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_seed_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_get_seed_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.seed_fingerprint.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_total_chunks_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_get_total_chunks",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.total_chunks.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_backup_hash_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_set_backup_hash",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            let api_backup_hash = <[u8; 32]>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.backup_hash = api_backup_hash;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_set_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.data = api_data;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_next_chunk_index_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_set_next_chunk_index",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            let api_next_chunk_index = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_chunk_index = api_next_chunk_index;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_seed_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_set_seed_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            let api_seed_fingerprint = <[u8; 32]>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.seed_fingerprint = api_seed_fingerprint;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_total_chunks_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "CollectBackupChunks_auto_accessor_set_total_chunks",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            let api_total_chunks = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.total_chunks = api_total_chunks;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__PrimeBackupFile_auto_accessor_get_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PrimeBackupFile_auto_accessor_get_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.data.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__PrimeBackupFile_auto_accessor_get_seed_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PrimeBackupFile_auto_accessor_get_seed_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.seed_fingerprint.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__PrimeBackupFile_auto_accessor_set_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PrimeBackupFile_auto_accessor_set_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>,
            >>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.data = api_data;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__PrimeBackupFile_auto_accessor_set_seed_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PrimeBackupFile_auto_accessor_set_seed_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>,
            >>::sse_decode(&mut deserializer);
            let api_seed_fingerprint = <[u8; 32]>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.seed_fingerprint = api_seed_fingerprint;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__ql__collect_backup_chunks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "collect_backup_chunks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_seed_fingerprint = <[u8; 32]>::sse_decode(&mut deserializer);
            let api_total_chunks = <u32>::sse_decode(&mut deserializer);
            let api_backup_hash = <[u8; 32]>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::ql::collect_backup_chunks(
                        api_seed_fingerprint,
                        api_total_chunks,
                        api_backup_hash,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__ql__decode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_decoder = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>,
            >>::sse_decode(&mut deserializer);
            let api_quantum_link_identity = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>,
            >>::sse_decode(&mut deserializer);
            let api_arid_cache = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_decoder_guard = None;
                        let mut api_quantum_link_identity_guard = None;
                        let mut api_arid_cache_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_decoder,
                                        0,
                                        true,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_quantum_link_identity,
                                        1,
                                        false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_arid_cache,
                                        2,
                                        true,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_decoder_guard =
                                        Some(api_decoder.lockable_decode_async_ref_mut().await)
                                }
                                1 => {
                                    api_quantum_link_identity_guard = Some(
                                        api_quantum_link_identity.lockable_decode_async_ref().await,
                                    )
                                }
                                2 => {
                                    api_arid_cache_guard =
                                        Some(api_arid_cache.lockable_decode_async_ref_mut().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let mut api_decoder_guard = api_decoder_guard.unwrap();
                        let api_quantum_link_identity_guard =
                            api_quantum_link_identity_guard.unwrap();
                        let mut api_arid_cache_guard = api_arid_cache_guard.unwrap();
                        let output_ok = crate::api::ql::decode(
                            api_data,
                            &mut *api_decoder_guard,
                            &*api_quantum_link_identity_guard,
                            &mut *api_arid_cache_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__qr__decode_ble_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_ble_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api__data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::qr::decode_ble_message(api__data).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__qr__decode_qr_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_qr",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_qr = <String>::sse_decode(&mut deserializer);
            let api_decoder = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Mutex<Decoder>>>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_decoder_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_decoder,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_decoder_guard =
                                        Some(api_decoder.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_decoder_guard = api_decoder_guard.unwrap();
                        let output_ok =
                            crate::api::qr::decode_qr(api_qr, &*api_decoder_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ql__deserialize_ql_identity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "deserialize_ql_identity",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::ql::deserialize_ql_identity(api_data)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__ql__deserialize_xid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "deserialize_xid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::ql::deserialize_xid(api_data)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__ql__encode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_message =
                <foundation_api::api::message::EnvoyMessage>::sse_decode(&mut deserializer);
            let api_sender = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>,
            >>::sse_decode(&mut deserializer);
            let api_recipient = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_sender_guard = None;
                        let mut api_recipient_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_sender,
                                        0,
                                        false,
                                    ),
                                    flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                        &api_recipient,
                                        1,
                                        false,
                                    ),
                                ],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_sender_guard =
                                        Some(api_sender.lockable_decode_async_ref().await)
                                }
                                1 => {
                                    api_recipient_guard =
                                        Some(api_recipient.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_sender_guard = api_sender_guard.unwrap();
                        let api_recipient_guard = api_recipient_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::ql::encode(
                                api_message,
                                &*api_sender_guard,
                                &*api_recipient_guard,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ql__generate_ql_identity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_ql_identity",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::ql::generate_ql_identity().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ql__get_arid_cache_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_arid_cache",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::ql::get_arid_cache())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__ql__get_decoder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_decoder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(crate::api::ql::get_decoder().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__qr__get_qr_decoder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_qr_decoder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::qr::get_qr_decoder().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__qr__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::qr::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__qr__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::qr::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__ql__push_backup_chunk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "push_backup_chunk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_this = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
            >>::sse_decode(&mut deserializer);
            let api_chunk =
                <foundation_api::api::backup::BackupChunk>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_this_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_this, 0, true,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_this_guard = Some(api_this.lockable_decode_sync_ref_mut()),
                                _ => unreachable!(),
                            }
                        }
                        let mut api_this_guard = api_this_guard.unwrap();
                        let output_ok =
                            crate::api::ql::push_backup_chunk(&mut *api_this_guard, api_chunk)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__ql__serialize_ql_identity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "serialize_ql_identity",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_quantum_link_identity = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_quantum_link_identity_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_quantum_link_identity,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_quantum_link_identity_guard = Some(
                                        api_quantum_link_identity.lockable_decode_async_ref().await,
                                    )
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_quantum_link_identity_guard =
                            api_quantum_link_identity_guard.unwrap();
                        let output_ok = crate::api::ql::serialize_ql_identity(
                            &*api_quantum_link_identity_guard,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ql__serialize_xid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "serialize_xid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_quantum_link_identity = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let mut api_quantum_link_identity_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_quantum_link_identity,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_quantum_link_identity_guard = Some(
                                        api_quantum_link_identity.lockable_decode_async_ref().await,
                                    )
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_quantum_link_identity_guard =
                            api_quantum_link_identity_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::ql::serialize_xid(&*api_quantum_link_identity_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__ql__serialize_xid_document_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "serialize_xid_document",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_xid_document = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_xid_document_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_xid_document,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_xid_document_guard =
                                        Some(api_xid_document.lockable_decode_sync_ref())
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_xid_document_guard = api_xid_document_guard.unwrap();
                        let output_ok =
                            crate::api::ql::serialize_xid_document(&*api_xid_document_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__ql__split_backup_into_chunks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "split_backup_into_chunks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_backup = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_chunk_size = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::ql::split_backup_into_chunks(
                        &api_backup,
                        api_chunk_size,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__ql__split_fw_update_into_chunks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "split_fw_update_into_chunks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_patch_index = <u8>::sse_decode(&mut deserializer);
            let api_total_patches = <u8>::sse_decode(&mut deserializer);
            let api_patch_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_chunk_size = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::ql::split_fw_update_into_chunks(
                                api_patch_index,
                                api_total_patches,
                                &api_patch_bytes,
                                api_chunk_size,
                            )
                            .await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let AccountUpdate = None::<foundation_api::api::bitcoin::AccountUpdate>.unwrap();
        let _: String = AccountUpdate.account_id;
        let _: Vec<u8> = AccountUpdate.update;
    }
    {
        let ApplyPassphrase = None::<foundation_api::api::bitcoin::ApplyPassphrase>.unwrap();
        let _: Option<String> = ApplyPassphrase.fingerprint;
    }
    {
        let BackupChunk = None::<foundation_api::api::backup::BackupChunk>.unwrap();
        let _: u32 = BackupChunk.chunk_index;
        let _: u32 = BackupChunk.total_chunks;
        let _: Vec<u8> = BackupChunk.data;
    }
    {
        let BackupMetadata = None::<foundation_api::api::backup::BackupMetadata>.unwrap();
        let _: u32 = BackupMetadata.total_chunks;
    }
    {
        let BackupShardRequest_ = None::<foundation_api::api::backup::BackupShardRequest>.unwrap();
        let _: foundation_api::api::backup::Shard = BackupShardRequest_.0;
    }
    match None::<foundation_api::api::backup::BackupShardResponse>.unwrap() {
        foundation_api::api::backup::BackupShardResponse::Success => {}
        foundation_api::api::backup::BackupShardResponse::Error(field0) => {
            let _: String = field0;
        }
    }
    {
        let BroadcastTransaction =
            None::<foundation_api::api::bitcoin::BroadcastTransaction>.unwrap();
        let _: String = BroadcastTransaction.account_id;
        let _: Vec<u8> = BroadcastTransaction.psbt;
    }
    {
        let ChallengeRequest = None::<foundation_api::api::scv::ChallengeRequest>.unwrap();
        let _: Vec<u8> = ChallengeRequest.data;
    }
    match None::<foundation_api::api::scv::ChallengeResponseResult>.unwrap() {
        foundation_api::api::scv::ChallengeResponseResult::Success { data } => {
            let _: Vec<u8> = data;
        }
        foundation_api::api::scv::ChallengeResponseResult::Error { error } => {
            let _: String = error;
        }
    }
    match None::<foundation_api::api::backup::CreateMagicBackupEvent>.unwrap() {
        foundation_api::api::backup::CreateMagicBackupEvent::Start(field0) => {
            let _: foundation_api::api::backup::StartMagicBackup = field0;
        }
        foundation_api::api::backup::CreateMagicBackupEvent::Chunk(field0) => {
            let _: foundation_api::api::backup::BackupChunk = field0;
        }
    }
    match None::<foundation_api::api::backup::CreateMagicBackupResult>.unwrap() {
        foundation_api::api::backup::CreateMagicBackupResult::Success => {}
        foundation_api::api::backup::CreateMagicBackupResult::Error(field0) => {
            let _: String = field0;
        }
    }
    {
        let DeviceStatus = None::<foundation_api::api::status::DeviceStatus>.unwrap();
        let _: foundation_api::api::status::DeviceState = DeviceStatus.state;
        let _: u8 = DeviceStatus.battery_level;
        let _: i8 = DeviceStatus.ble_signal;
        let _: String = DeviceStatus.version;
    }
    {
        let EnvoyMagicBackupEnabledRequest =
            None::<foundation_api::api::backup::EnvoyMagicBackupEnabledRequest>.unwrap();
    }
    {
        let EnvoyMagicBackupEnabledResponse =
            None::<foundation_api::api::backup::EnvoyMagicBackupEnabledResponse>.unwrap();
        let _: bool = EnvoyMagicBackupEnabledResponse.enabled;
    }
    {
        let EnvoyMessage = None::<foundation_api::api::message::EnvoyMessage>.unwrap();
        let _: foundation_api::api::message::QuantumLinkMessage = EnvoyMessage.message;
        let _: u32 = EnvoyMessage.timestamp;
    }
    {
        let EnvoyStatus = None::<foundation_api::api::status::EnvoyStatus>.unwrap();
        let _: foundation_api::api::status::EnvoyState = EnvoyStatus.state;
        let _: String = EnvoyStatus.version;
    }
    {
        let ExchangeRate = None::<foundation_api::api::fx::ExchangeRate>.unwrap();
        let _: String = ExchangeRate.currency_code;
        let _: f32 = ExchangeRate.rate;
        let _: u64 = ExchangeRate.timestamp;
    }
    {
        let ExchangeRateHistory = None::<foundation_api::api::fx::ExchangeRateHistory>.unwrap();
        let _: Vec<foundation_api::api::fx::PricePoint> = ExchangeRateHistory.history;
        let _: String = ExchangeRateHistory.currency_code;
    }
    {
        let FirmwareChunk = None::<foundation_api::api::firmware::FirmwareChunk>.unwrap();
        let _: u8 = FirmwareChunk.patch_index;
        let _: u8 = FirmwareChunk.total_patches;
        let _: u16 = FirmwareChunk.chunk_index;
        let _: u16 = FirmwareChunk.total_chunks;
        let _: Vec<u8> = FirmwareChunk.data;
    }
    match None::<foundation_api::api::firmware::FirmwareFetchEvent>.unwrap() {
        foundation_api::api::firmware::FirmwareFetchEvent::UpdateNotAvailable => {}
        foundation_api::api::firmware::FirmwareFetchEvent::Starting(field0) => {
            let _: foundation_api::api::firmware::FirmwareUpdateAvailable = field0;
        }
        foundation_api::api::firmware::FirmwareFetchEvent::Downloading => {}
        foundation_api::api::firmware::FirmwareFetchEvent::Chunk(field0) => {
            let _: foundation_api::api::firmware::FirmwareChunk = field0;
        }
        foundation_api::api::firmware::FirmwareFetchEvent::Complete => {}
        foundation_api::api::firmware::FirmwareFetchEvent::Error(field0) => {
            let _: String = field0;
        }
    }
    {
        let FirmwareFetchRequest =
            None::<foundation_api::api::firmware::FirmwareFetchRequest>.unwrap();
        let _: String = FirmwareFetchRequest.current_version;
    }
    {
        let FirmwareUpdateAvailable =
            None::<foundation_api::api::firmware::FirmwareUpdateAvailable>.unwrap();
        let _: String = FirmwareUpdateAvailable.version;
        let _: String = FirmwareUpdateAvailable.changelog;
        let _: u32 = FirmwareUpdateAvailable.timestamp;
        let _: u32 = FirmwareUpdateAvailable.total_size;
        let _: u8 = FirmwareUpdateAvailable.patch_count;
    }
    {
        let FirmwareUpdateCheckRequest =
            None::<foundation_api::api::firmware::FirmwareUpdateCheckRequest>.unwrap();
        let _: String = FirmwareUpdateCheckRequest.current_version;
    }
    match None::<foundation_api::api::firmware::FirmwareUpdateCheckResponse>.unwrap() {
        foundation_api::api::firmware::FirmwareUpdateCheckResponse::Available(field0) => {
            let _: foundation_api::api::firmware::FirmwareUpdateAvailable = field0;
        }
        foundation_api::api::firmware::FirmwareUpdateCheckResponse::NotAvailable => {}
    }
    match None::<foundation_api::api::firmware::FirmwareUpdateResult>.unwrap() {
        foundation_api::api::firmware::FirmwareUpdateResult::Success { installed_version } => {
            let _: String = installed_version;
        }
        foundation_api::api::firmware::FirmwareUpdateResult::Error(field0) => {
            let _: String = field0;
        }
    }
    {
        let PairingRequest = None::<foundation_api::api::pairing::PairingRequest>.unwrap();
        let _: Vec<u8> = PairingRequest.xid_document;
    }
    {
        let PairingResponse = None::<foundation_api::api::pairing::PairingResponse>.unwrap();
        let _: foundation_api::api::passport::PassportModel = PairingResponse.passport_model;
        let _: foundation_api::api::passport::PassportFirmwareVersion =
            PairingResponse.passport_firmware_version;
        let _: foundation_api::api::passport::PassportSerial = PairingResponse.passport_serial;
        let _: foundation_api::api::passport::PassportColor = PairingResponse.passport_color;
        let _: bool = PairingResponse.onboarding_complete;
    }
    {
        let PassportFirmwareVersion_ =
            None::<foundation_api::api::passport::PassportFirmwareVersion>.unwrap();
        let _: String = PassportFirmwareVersion_.0;
    }
    {
        let PassportMessage = None::<foundation_api::api::message::PassportMessage>.unwrap();
        let _: foundation_api::api::message::QuantumLinkMessage = PassportMessage.message;
        let _: foundation_api::api::status::DeviceStatus = PassportMessage.status;
    }
    {
        let PassportSerial_ = None::<foundation_api::api::passport::PassportSerial>.unwrap();
        let _: String = PassportSerial_.0;
    }
    {
        let PricePoint = None::<foundation_api::api::fx::PricePoint>.unwrap();
        let _: f32 = PricePoint.rate;
        let _: u64 = PricePoint.timestamp;
    }
    {
        let PrimeMagicBackupEnabled =
            None::<foundation_api::api::backup::PrimeMagicBackupEnabled>.unwrap();
        let _: bool = PrimeMagicBackupEnabled.enabled;
        let _: [u8; 32] = PrimeMagicBackupEnabled.seed_fingerprint;
    }
    {
        let PrimeMagicBackupStatusRequest =
            None::<foundation_api::api::backup::PrimeMagicBackupStatusRequest>.unwrap();
        let _: [u8; 32] = PrimeMagicBackupStatusRequest.seed_fingerprint;
    }
    {
        let PrimeMagicBackupStatusResponse =
            None::<foundation_api::api::backup::PrimeMagicBackupStatusResponse>.unwrap();
        let _: bool = PrimeMagicBackupStatusResponse.shard_backup_found;
    }
    match None::<foundation_api::api::message::QuantumLinkMessage>.unwrap() {
        foundation_api::api::message::QuantumLinkMessage::ExchangeRate(field0) => {
            let _: foundation_api::api::fx::ExchangeRate = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::ExchangeRateHistory(field0) => {
            let _: foundation_api::api::fx::ExchangeRateHistory = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckRequest(field0) => {
            let _: foundation_api::api::firmware::FirmwareUpdateCheckRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckResponse(field0) => {
            let _: foundation_api::api::firmware::FirmwareUpdateCheckResponse = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::FirmwareFetchRequest(field0) => {
            let _: foundation_api::api::firmware::FirmwareFetchRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::FirmwareFetchEvent(field0) => {
            let _: foundation_api::api::firmware::FirmwareFetchEvent = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateResult(field0) => {
            let _: foundation_api::api::firmware::FirmwareUpdateResult = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::DeviceStatus(field0) => {
            let _: foundation_api::api::status::DeviceStatus = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::EnvoyStatus(field0) => {
            let _: foundation_api::api::status::EnvoyStatus = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::PairingRequest(field0) => {
            let _: foundation_api::api::pairing::PairingRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::PairingResponse(field0) => {
            let _: foundation_api::api::pairing::PairingResponse = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::OnboardingState(field0) => {
            let _: foundation_api::api::onboarding::OnboardingState = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::SignPsbt(field0) => {
            let _: foundation_api::api::bitcoin::SignPsbt = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::BroadcastTransaction(field0) => {
            let _: foundation_api::api::bitcoin::BroadcastTransaction = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::AccountUpdate(field0) => {
            let _: foundation_api::api::bitcoin::AccountUpdate = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::ApplyPassphrase(field0) => {
            let _: foundation_api::api::bitcoin::ApplyPassphrase = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::SecurityCheck(field0) => {
            let _: foundation_api::api::scv::SecurityCheck = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledRequest(
            field0,
        ) => {
            let _: foundation_api::api::backup::EnvoyMagicBackupEnabledRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledResponse(
            field0,
        ) => {
            let _: foundation_api::api::backup::EnvoyMagicBackupEnabledResponse = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupEnabled(field0) => {
            let _: foundation_api::api::backup::PrimeMagicBackupEnabled = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusRequest(field0) => {
            let _: foundation_api::api::backup::PrimeMagicBackupStatusRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusResponse(
            field0,
        ) => {
            let _: foundation_api::api::backup::PrimeMagicBackupStatusResponse = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::BackupShardRequest(field0) => {
            let _: foundation_api::api::backup::BackupShardRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::BackupShardResponse(field0) => {
            let _: foundation_api::api::backup::BackupShardResponse = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::RestoreShardRequest(field0) => {
            let _: foundation_api::api::backup::RestoreShardRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::RestoreShardResponse(field0) => {
            let _: foundation_api::api::backup::RestoreShardResponse = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupEvent(field0) => {
            let _: foundation_api::api::backup::CreateMagicBackupEvent = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupResult(field0) => {
            let _: foundation_api::api::backup::CreateMagicBackupResult = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupRequest(field0) => {
            let _: foundation_api::api::backup::RestoreMagicBackupRequest = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupEvent(field0) => {
            let _: foundation_api::api::backup::RestoreMagicBackupEvent = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupResult(field0) => {
            let _: foundation_api::api::backup::RestoreMagicBackupResult = field0;
        }
        foundation_api::api::message::QuantumLinkMessage::RawData(field0) => {
            let _: foundation_api::api::raw::RawData = field0;
        }
    }
    {
        let RawData = None::<foundation_api::api::raw::RawData>.unwrap();
        let _: Vec<u8> = RawData.payload;
    }
    match None::<foundation_api::api::backup::RestoreMagicBackupEvent>.unwrap() {
        foundation_api::api::backup::RestoreMagicBackupEvent::NoBackupFound => {}
        foundation_api::api::backup::RestoreMagicBackupEvent::Starting(field0) => {
            let _: foundation_api::api::backup::BackupMetadata = field0;
        }
        foundation_api::api::backup::RestoreMagicBackupEvent::Chunk(field0) => {
            let _: foundation_api::api::backup::BackupChunk = field0;
        }
        foundation_api::api::backup::RestoreMagicBackupEvent::Error(field0) => {
            let _: String = field0;
        }
    }
    {
        let RestoreMagicBackupRequest =
            None::<foundation_api::api::backup::RestoreMagicBackupRequest>.unwrap();
        let _: [u8; 32] = RestoreMagicBackupRequest.seed_fingerprint;
        let _: u32 = RestoreMagicBackupRequest.resume_from_chunk;
    }
    match None::<foundation_api::api::backup::RestoreMagicBackupResult>.unwrap() {
        foundation_api::api::backup::RestoreMagicBackupResult::Success => {}
        foundation_api::api::backup::RestoreMagicBackupResult::Error(field0) => {
            let _: String = field0;
        }
    }
    {
        let RestoreShardRequest = None::<foundation_api::api::backup::RestoreShardRequest>.unwrap();
        let _: [u8; 32] = RestoreShardRequest.seed_fingerprint;
    }
    match None::<foundation_api::api::backup::RestoreShardResponse>.unwrap() {
        foundation_api::api::backup::RestoreShardResponse::Success(field0) => {
            let _: foundation_api::api::backup::Shard = field0;
        }
        foundation_api::api::backup::RestoreShardResponse::Error(field0) => {
            let _: String = field0;
        }
        foundation_api::api::backup::RestoreShardResponse::NotFound(field0) => {
            let _: String = field0;
        }
    }
    match None::<foundation_api::api::scv::SecurityCheck>.unwrap() {
        foundation_api::api::scv::SecurityCheck::ChallengeRequest(field0) => {
            let _: foundation_api::api::scv::ChallengeRequest = field0;
        }
        foundation_api::api::scv::SecurityCheck::ChallengeResponse(field0) => {
            let _: foundation_api::api::scv::ChallengeResponseResult = field0;
        }
        foundation_api::api::scv::SecurityCheck::VerificationResult(field0) => {
            let _: foundation_api::api::scv::VerificationResult = field0;
        }
    }
    {
        let Shard = None::<foundation_api::api::backup::Shard>.unwrap();
        let _: Vec<u8> = Shard.payload;
    }
    {
        let SignPsbt = None::<foundation_api::api::bitcoin::SignPsbt>.unwrap();
        let _: String = SignPsbt.account_id;
        let _: Vec<u8> = SignPsbt.psbt;
    }
    {
        let StartMagicBackup = None::<foundation_api::api::backup::StartMagicBackup>.unwrap();
        let _: [u8; 32] = StartMagicBackup.seed_fingerprint;
        let _: u32 = StartMagicBackup.total_chunks;
        let _: [u8; 32] = StartMagicBackup.hash;
    }
    match None::<foundation_api::api::scv::VerificationResult>.unwrap() {
        foundation_api::api::scv::VerificationResult::Success => {}
        foundation_api::api::scv::VerificationResult::Error { error } => {
            let _: String = error;
        }
    }
};

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Mutex<Decoder>>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for Arc<Mutex<Decoder>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Mutex<Decoder>>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for CollectBackupChunks {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EnvoyARIDCache {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EnvoyMasterDechunker {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PrimeBackupFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for QuantumLinkIdentity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for XIDDocument {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Mutex<Decoder>>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for foundation_api::api::bitcoin::AccountUpdate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_accountId = <String>::sse_decode(deserializer);
        let mut var_update = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::bitcoin::AccountUpdate {
            account_id: var_accountId,
            update: var_update,
        };
    }
}

impl SseDecode for foundation_api::api::bitcoin::ApplyPassphrase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fingerprint = <Option<String>>::sse_decode(deserializer);
        return foundation_api::api::bitcoin::ApplyPassphrase {
            fingerprint: var_fingerprint,
        };
    }
}

impl SseDecode for foundation_api::api::backup::BackupChunk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chunkIndex = <u32>::sse_decode(deserializer);
        let mut var_totalChunks = <u32>::sse_decode(deserializer);
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::backup::BackupChunk {
            chunk_index: var_chunkIndex,
            total_chunks: var_totalChunks,
            data: var_data,
        };
    }
}

impl SseDecode for foundation_api::api::backup::BackupMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalChunks = <u32>::sse_decode(deserializer);
        return foundation_api::api::backup::BackupMetadata {
            total_chunks: var_totalChunks,
        };
    }
}

impl SseDecode for foundation_api::api::backup::BackupShardRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <foundation_api::api::backup::Shard>::sse_decode(deserializer);
        return foundation_api::api::backup::BackupShardRequest(var_field0);
    }
}

impl SseDecode for foundation_api::api::backup::BackupShardResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return foundation_api::api::backup::BackupShardResponse::Success;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::backup::BackupShardResponse::Error(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for foundation_api::api::bitcoin::BroadcastTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_accountId = <String>::sse_decode(deserializer);
        let mut var_psbt = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::bitcoin::BroadcastTransaction {
            account_id: var_accountId,
            psbt: var_psbt,
        };
    }
}

impl SseDecode for foundation_api::api::scv::ChallengeRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::scv::ChallengeRequest { data: var_data };
    }
}

impl SseDecode for foundation_api::api::scv::ChallengeResponseResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_data = <Vec<u8>>::sse_decode(deserializer);
                return foundation_api::api::scv::ChallengeResponseResult::Success {
                    data: var_data,
                };
            }
            1 => {
                let mut var_error = <String>::sse_decode(deserializer);
                return foundation_api::api::scv::ChallengeResponseResult::Error {
                    error: var_error,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::backup::CreateMagicBackupEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <foundation_api::api::backup::StartMagicBackup>::sse_decode(deserializer);
                return foundation_api::api::backup::CreateMagicBackupEvent::Start(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <foundation_api::api::backup::BackupChunk>::sse_decode(deserializer);
                return foundation_api::api::backup::CreateMagicBackupEvent::Chunk(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::backup::CreateMagicBackupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return foundation_api::api::backup::CreateMagicBackupResult::Success;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::backup::CreateMagicBackupResult::Error(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::ql::DecoderStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_progress = <f64>::sse_decode(deserializer);
        let mut var_payload =
            <Option<foundation_api::api::message::PassportMessage>>::sse_decode(deserializer);
        return crate::api::ql::DecoderStatus {
            progress: var_progress,
            payload: var_payload,
        };
    }
}

impl SseDecode for foundation_api::api::status::DeviceState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => foundation_api::api::status::DeviceState::Normal,
            1 => foundation_api::api::status::DeviceState::UpdatingFirmware,
            2 => foundation_api::api::status::DeviceState::Rebooting,
            _ => unreachable!("Invalid variant for DeviceState: {}", inner),
        };
    }
}

impl SseDecode for foundation_api::api::status::DeviceStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_state = <foundation_api::api::status::DeviceState>::sse_decode(deserializer);
        let mut var_batteryLevel = <u8>::sse_decode(deserializer);
        let mut var_bleSignal = <i8>::sse_decode(deserializer);
        let mut var_version = <String>::sse_decode(deserializer);
        return foundation_api::api::status::DeviceStatus {
            state: var_state,
            battery_level: var_batteryLevel,
            ble_signal: var_bleSignal,
            version: var_version,
        };
    }
}

impl SseDecode for foundation_api::api::backup::EnvoyMagicBackupEnabledRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return foundation_api::api::backup::EnvoyMagicBackupEnabledRequest {};
    }
}

impl SseDecode for foundation_api::api::backup::EnvoyMagicBackupEnabledResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_enabled = <bool>::sse_decode(deserializer);
        return foundation_api::api::backup::EnvoyMagicBackupEnabledResponse {
            enabled: var_enabled,
        };
    }
}

impl SseDecode for foundation_api::api::message::EnvoyMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message =
            <foundation_api::api::message::QuantumLinkMessage>::sse_decode(deserializer);
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        return foundation_api::api::message::EnvoyMessage {
            message: var_message,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for foundation_api::api::status::EnvoyState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => foundation_api::api::status::EnvoyState::Normal,
            1 => foundation_api::api::status::EnvoyState::DownloadingFirmware,
            _ => unreachable!("Invalid variant for EnvoyState: {}", inner),
        };
    }
}

impl SseDecode for foundation_api::api::status::EnvoyStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_state = <foundation_api::api::status::EnvoyState>::sse_decode(deserializer);
        let mut var_version = <String>::sse_decode(deserializer);
        return foundation_api::api::status::EnvoyStatus {
            state: var_state,
            version: var_version,
        };
    }
}

impl SseDecode for foundation_api::api::fx::ExchangeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currencyCode = <String>::sse_decode(deserializer);
        let mut var_rate = <f32>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return foundation_api::api::fx::ExchangeRate {
            currency_code: var_currencyCode,
            rate: var_rate,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for foundation_api::api::fx::ExchangeRateHistory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_history = <Vec<foundation_api::api::fx::PricePoint>>::sse_decode(deserializer);
        let mut var_currencyCode = <String>::sse_decode(deserializer);
        return foundation_api::api::fx::ExchangeRateHistory {
            history: var_history,
            currency_code: var_currencyCode,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareChunk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_patchIndex = <u8>::sse_decode(deserializer);
        let mut var_totalPatches = <u8>::sse_decode(deserializer);
        let mut var_chunkIndex = <u16>::sse_decode(deserializer);
        let mut var_totalChunks = <u16>::sse_decode(deserializer);
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::firmware::FirmwareChunk {
            patch_index: var_patchIndex,
            total_patches: var_totalPatches,
            chunk_index: var_chunkIndex,
            total_chunks: var_totalChunks,
            data: var_data,
        };
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareFetchEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return foundation_api::api::firmware::FirmwareFetchEvent::UpdateNotAvailable;
            }
            1 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareUpdateAvailable>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::firmware::FirmwareFetchEvent::Starting(var_field0);
            }
            2 => {
                return foundation_api::api::firmware::FirmwareFetchEvent::Downloading;
            }
            3 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareChunk>::sse_decode(deserializer);
                return foundation_api::api::firmware::FirmwareFetchEvent::Chunk(var_field0);
            }
            4 => {
                return foundation_api::api::firmware::FirmwareFetchEvent::Complete;
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::firmware::FirmwareFetchEvent::Error(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareFetchRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currentVersion = <String>::sse_decode(deserializer);
        return foundation_api::api::firmware::FirmwareFetchRequest {
            current_version: var_currentVersion,
        };
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareUpdateAvailable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <String>::sse_decode(deserializer);
        let mut var_changelog = <String>::sse_decode(deserializer);
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        let mut var_totalSize = <u32>::sse_decode(deserializer);
        let mut var_patchCount = <u8>::sse_decode(deserializer);
        return foundation_api::api::firmware::FirmwareUpdateAvailable {
            version: var_version,
            changelog: var_changelog,
            timestamp: var_timestamp,
            total_size: var_totalSize,
            patch_count: var_patchCount,
        };
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareUpdateCheckRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_currentVersion = <String>::sse_decode(deserializer);
        return foundation_api::api::firmware::FirmwareUpdateCheckRequest {
            current_version: var_currentVersion,
        };
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareUpdateCheckResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareUpdateAvailable>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::firmware::FirmwareUpdateCheckResponse::Available(
                    var_field0,
                );
            }
            1 => {
                return foundation_api::api::firmware::FirmwareUpdateCheckResponse::NotAvailable;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::firmware::FirmwareUpdateResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_installedVersion = <String>::sse_decode(deserializer);
                return foundation_api::api::firmware::FirmwareUpdateResult::Success {
                    installed_version: var_installedVersion,
                };
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::firmware::FirmwareUpdateResult::Error(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i8().unwrap()
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<foundation_api::api::fx::PricePoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<foundation_api::api::fx::PricePoint>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<foundation_api::api::message::QuantumLinkMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<foundation_api::api::message::QuantumLinkMessage>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for foundation_api::api::onboarding::OnboardingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => foundation_api::api::onboarding::OnboardingState::FirmwareUpdateScreen,
            1 => foundation_api::api::onboarding::OnboardingState::DownloadingUpdate,
            2 => foundation_api::api::onboarding::OnboardingState::ReceivingUpdate,
            3 => foundation_api::api::onboarding::OnboardingState::VeryfyingSignatures,
            4 => foundation_api::api::onboarding::OnboardingState::InstallingUpdate,
            5 => foundation_api::api::onboarding::OnboardingState::Rebooting,
            6 => foundation_api::api::onboarding::OnboardingState::FirmwareUpdated,
            7 => foundation_api::api::onboarding::OnboardingState::SecuringDevice,
            8 => foundation_api::api::onboarding::OnboardingState::DeviceSecured,
            9 => foundation_api::api::onboarding::OnboardingState::WalletCreationScreen,
            10 => foundation_api::api::onboarding::OnboardingState::CreatingWallet,
            11 => foundation_api::api::onboarding::OnboardingState::WalletCreated,
            12 => foundation_api::api::onboarding::OnboardingState::MagicBackupScreen,
            13 => foundation_api::api::onboarding::OnboardingState::CreatingMagicBackup,
            14 => foundation_api::api::onboarding::OnboardingState::MagicBackupCreated,
            15 => foundation_api::api::onboarding::OnboardingState::CreatingManualBackup,
            16 => foundation_api::api::onboarding::OnboardingState::CreatingKeycardBackup,
            17 => foundation_api::api::onboarding::OnboardingState::WritingDownSeedWords,
            18 => foundation_api::api::onboarding::OnboardingState::ConnectingWallet,
            19 => foundation_api::api::onboarding::OnboardingState::WalletConected,
            20 => foundation_api::api::onboarding::OnboardingState::Completed,
            21 => foundation_api::api::onboarding::OnboardingState::SecurityChecked,
            22 => foundation_api::api::onboarding::OnboardingState::UpdateAvailable,
            23 => foundation_api::api::onboarding::OnboardingState::UpdateNotAvailable,
            24 => foundation_api::api::onboarding::OnboardingState::SecurityCheckFailed,
            _ => unreachable!("Invalid variant for OnboardingState: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<PrimeBackupFile> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<PrimeBackupFile>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<XIDDocument> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<XIDDocument>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<foundation_api::api::message::PassportMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<foundation_api::api::message::PassportMessage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for foundation_api::api::pairing::PairingRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_xidDocument = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::pairing::PairingRequest {
            xid_document: var_xidDocument,
        };
    }
}

impl SseDecode for foundation_api::api::pairing::PairingResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_passportModel =
            <foundation_api::api::passport::PassportModel>::sse_decode(deserializer);
        let mut var_passportFirmwareVersion =
            <foundation_api::api::passport::PassportFirmwareVersion>::sse_decode(deserializer);
        let mut var_passportSerial =
            <foundation_api::api::passport::PassportSerial>::sse_decode(deserializer);
        let mut var_passportColor =
            <foundation_api::api::passport::PassportColor>::sse_decode(deserializer);
        let mut var_onboardingComplete = <bool>::sse_decode(deserializer);
        return foundation_api::api::pairing::PairingResponse {
            passport_model: var_passportModel,
            passport_firmware_version: var_passportFirmwareVersion,
            passport_serial: var_passportSerial,
            passport_color: var_passportColor,
            onboarding_complete: var_onboardingComplete,
        };
    }
}

impl SseDecode for foundation_api::api::passport::PassportColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => foundation_api::api::passport::PassportColor::Light,
            1 => foundation_api::api::passport::PassportColor::Dark,
            _ => unreachable!("Invalid variant for PassportColor: {}", inner),
        };
    }
}

impl SseDecode for foundation_api::api::passport::PassportFirmwareVersion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        return foundation_api::api::passport::PassportFirmwareVersion(var_field0);
    }
}

impl SseDecode for foundation_api::api::message::PassportMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message =
            <foundation_api::api::message::QuantumLinkMessage>::sse_decode(deserializer);
        let mut var_status = <foundation_api::api::status::DeviceStatus>::sse_decode(deserializer);
        return foundation_api::api::message::PassportMessage {
            message: var_message,
            status: var_status,
        };
    }
}

impl SseDecode for foundation_api::api::passport::PassportModel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => foundation_api::api::passport::PassportModel::Gen1,
            1 => foundation_api::api::passport::PassportModel::Gen2,
            2 => foundation_api::api::passport::PassportModel::Prime,
            _ => unreachable!("Invalid variant for PassportModel: {}", inner),
        };
    }
}

impl SseDecode for foundation_api::api::passport::PassportSerial {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        return foundation_api::api::passport::PassportSerial(var_field0);
    }
}

impl SseDecode for foundation_api::api::fx::PricePoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rate = <f32>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return foundation_api::api::fx::PricePoint {
            rate: var_rate,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for foundation_api::api::backup::PrimeMagicBackupEnabled {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_seedFingerprint = <[u8; 32]>::sse_decode(deserializer);
        return foundation_api::api::backup::PrimeMagicBackupEnabled {
            enabled: var_enabled,
            seed_fingerprint: var_seedFingerprint,
        };
    }
}

impl SseDecode for foundation_api::api::backup::PrimeMagicBackupStatusRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedFingerprint = <[u8; 32]>::sse_decode(deserializer);
        return foundation_api::api::backup::PrimeMagicBackupStatusRequest {
            seed_fingerprint: var_seedFingerprint,
        };
    }
}

impl SseDecode for foundation_api::api::backup::PrimeMagicBackupStatusResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_shardBackupFound = <bool>::sse_decode(deserializer);
        return foundation_api::api::backup::PrimeMagicBackupStatusResponse {
            shard_backup_found: var_shardBackupFound,
        };
    }
}

impl SseDecode for crate::api::qr::QrDecoderStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_progress = <f64>::sse_decode(deserializer);
        let mut var_payload = <Option<XIDDocument>>::sse_decode(deserializer);
        return crate::api::qr::QrDecoderStatus {
            progress: var_progress,
            payload: var_payload,
        };
    }
}

impl SseDecode for foundation_api::api::message::QuantumLinkMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <foundation_api::api::fx::ExchangeRate>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::ExchangeRate(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <foundation_api::api::fx::ExchangeRateHistory>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::ExchangeRateHistory(
                    var_field0,
                );
            }
            2 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareUpdateCheckRequest>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckRequest(var_field0);
            }
            3 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareUpdateCheckResponse>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckResponse(var_field0);
            }
            4 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareFetchRequest>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::FirmwareFetchRequest(
                    var_field0,
                );
            }
            5 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareFetchEvent>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::FirmwareFetchEvent(
                    var_field0,
                );
            }
            6 => {
                let mut var_field0 =
                    <foundation_api::api::firmware::FirmwareUpdateResult>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateResult(
                    var_field0,
                );
            }
            7 => {
                let mut var_field0 =
                    <foundation_api::api::status::DeviceStatus>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::DeviceStatus(var_field0);
            }
            8 => {
                let mut var_field0 =
                    <foundation_api::api::status::EnvoyStatus>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::EnvoyStatus(var_field0);
            }
            9 => {
                let mut var_field0 =
                    <foundation_api::api::pairing::PairingRequest>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::PairingRequest(
                    var_field0,
                );
            }
            10 => {
                let mut var_field0 =
                    <foundation_api::api::pairing::PairingResponse>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::PairingResponse(
                    var_field0,
                );
            }
            11 => {
                let mut var_field0 =
                    <foundation_api::api::onboarding::OnboardingState>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::OnboardingState(
                    var_field0,
                );
            }
            12 => {
                let mut var_field0 =
                    <foundation_api::api::bitcoin::SignPsbt>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::SignPsbt(var_field0);
            }
            13 => {
                let mut var_field0 =
                    <foundation_api::api::bitcoin::BroadcastTransaction>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::BroadcastTransaction(
                    var_field0,
                );
            }
            14 => {
                let mut var_field0 =
                    <foundation_api::api::bitcoin::AccountUpdate>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::AccountUpdate(var_field0);
            }
            15 => {
                let mut var_field0 =
                    <foundation_api::api::bitcoin::ApplyPassphrase>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::ApplyPassphrase(
                    var_field0,
                );
            }
            16 => {
                let mut var_field0 =
                    <foundation_api::api::scv::SecurityCheck>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::SecurityCheck(var_field0);
            }
            17 => {
                let mut var_field0 =
                    <foundation_api::api::backup::EnvoyMagicBackupEnabledRequest>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledRequest(var_field0);
            }
            18 => {
                let mut var_field0 =
                    <foundation_api::api::backup::EnvoyMagicBackupEnabledResponse>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledResponse(var_field0);
            }
            19 => {
                let mut var_field0 =
                    <foundation_api::api::backup::PrimeMagicBackupEnabled>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupEnabled(
                    var_field0,
                );
            }
            20 => {
                let mut var_field0 =
                    <foundation_api::api::backup::PrimeMagicBackupStatusRequest>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusRequest(var_field0);
            }
            21 => {
                let mut var_field0 =
                    <foundation_api::api::backup::PrimeMagicBackupStatusResponse>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusResponse(var_field0);
            }
            22 => {
                let mut var_field0 =
                    <foundation_api::api::backup::BackupShardRequest>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::BackupShardRequest(
                    var_field0,
                );
            }
            23 => {
                let mut var_field0 =
                    <foundation_api::api::backup::BackupShardResponse>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::BackupShardResponse(
                    var_field0,
                );
            }
            24 => {
                let mut var_field0 =
                    <foundation_api::api::backup::RestoreShardRequest>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::RestoreShardRequest(
                    var_field0,
                );
            }
            25 => {
                let mut var_field0 =
                    <foundation_api::api::backup::RestoreShardResponse>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::RestoreShardResponse(
                    var_field0,
                );
            }
            26 => {
                let mut var_field0 =
                    <foundation_api::api::backup::CreateMagicBackupEvent>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupEvent(
                    var_field0,
                );
            }
            27 => {
                let mut var_field0 =
                    <foundation_api::api::backup::CreateMagicBackupResult>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupResult(
                    var_field0,
                );
            }
            28 => {
                let mut var_field0 =
                    <foundation_api::api::backup::RestoreMagicBackupRequest>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupRequest(
                    var_field0,
                );
            }
            29 => {
                let mut var_field0 =
                    <foundation_api::api::backup::RestoreMagicBackupEvent>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupEvent(
                    var_field0,
                );
            }
            30 => {
                let mut var_field0 =
                    <foundation_api::api::backup::RestoreMagicBackupResult>::sse_decode(
                        deserializer,
                    );
                return foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupResult(
                    var_field0,
                );
            }
            31 => {
                let mut var_field0 = <foundation_api::api::raw::RawData>::sse_decode(deserializer);
                return foundation_api::api::message::QuantumLinkMessage::RawData(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::raw::RawData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payload = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::raw::RawData {
            payload: var_payload,
        };
    }
}

impl SseDecode for foundation_api::api::backup::RestoreMagicBackupEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return foundation_api::api::backup::RestoreMagicBackupEvent::NoBackupFound;
            }
            1 => {
                let mut var_field0 =
                    <foundation_api::api::backup::BackupMetadata>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreMagicBackupEvent::Starting(var_field0);
            }
            2 => {
                let mut var_field0 =
                    <foundation_api::api::backup::BackupChunk>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreMagicBackupEvent::Chunk(var_field0);
            }
            3 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreMagicBackupEvent::Error(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::backup::RestoreMagicBackupRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedFingerprint = <[u8; 32]>::sse_decode(deserializer);
        let mut var_resumeFromChunk = <u32>::sse_decode(deserializer);
        return foundation_api::api::backup::RestoreMagicBackupRequest {
            seed_fingerprint: var_seedFingerprint,
            resume_from_chunk: var_resumeFromChunk,
        };
    }
}

impl SseDecode for foundation_api::api::backup::RestoreMagicBackupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return foundation_api::api::backup::RestoreMagicBackupResult::Success;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreMagicBackupResult::Error(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::backup::RestoreShardRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedFingerprint = <[u8; 32]>::sse_decode(deserializer);
        return foundation_api::api::backup::RestoreShardRequest {
            seed_fingerprint: var_seedFingerprint,
        };
    }
}

impl SseDecode for foundation_api::api::backup::RestoreShardResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <foundation_api::api::backup::Shard>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreShardResponse::Success(var_field0);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreShardResponse::Error(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return foundation_api::api::backup::RestoreShardResponse::NotFound(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::scv::SecurityCheck {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <foundation_api::api::scv::ChallengeRequest>::sse_decode(deserializer);
                return foundation_api::api::scv::SecurityCheck::ChallengeRequest(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <foundation_api::api::scv::ChallengeResponseResult>::sse_decode(deserializer);
                return foundation_api::api::scv::SecurityCheck::ChallengeResponse(var_field0);
            }
            2 => {
                let mut var_field0 =
                    <foundation_api::api::scv::VerificationResult>::sse_decode(deserializer);
                return foundation_api::api::scv::SecurityCheck::VerificationResult(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for foundation_api::api::backup::Shard {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_payload = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::backup::Shard {
            payload: var_payload,
        };
    }
}

impl SseDecode for foundation_api::api::bitcoin::SignPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_accountId = <String>::sse_decode(deserializer);
        let mut var_psbt = <Vec<u8>>::sse_decode(deserializer);
        return foundation_api::api::bitcoin::SignPsbt {
            account_id: var_accountId,
            psbt: var_psbt,
        };
    }
}

impl SseDecode for foundation_api::api::backup::StartMagicBackup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedFingerprint = <[u8; 32]>::sse_decode(deserializer);
        let mut var_totalChunks = <u32>::sse_decode(deserializer);
        let mut var_hash = <[u8; 32]>::sse_decode(deserializer);
        return foundation_api::api::backup::StartMagicBackup {
            seed_fingerprint: var_seedFingerprint,
            total_chunks: var_totalChunks,
            hash: var_hash,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for foundation_api::api::scv::VerificationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return foundation_api::api::scv::VerificationResult::Success;
            }
            1 => {
                let mut var_error = <String>::sse_decode(deserializer);
                return foundation_api::api::scv::VerificationResult::Error { error: var_error };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        15 => wire__crate__api__ql__collect_backup_chunks_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__ql__decode_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__qr__decode_ble_message_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__qr__decode_qr_impl(port, ptr, rust_vec_len, data_len),
        19 => wire__crate__api__ql__deserialize_ql_identity_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__ql__deserialize_xid_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__ql__encode_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__ql__generate_ql_identity_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__api__ql__get_arid_cache_impl(port, ptr, rust_vec_len, data_len),
        24 => wire__crate__api__ql__get_decoder_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__qr__get_qr_decoder_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__qr__init_app_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__ql__push_backup_chunk_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__api__ql__serialize_ql_identity_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__api__ql__serialize_xid_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__ql__serialize_xid_document_impl(port, ptr, rust_vec_len, data_len),
        32 => {
            wire__crate__api__ql__split_backup_into_chunks_impl(port, ptr, rust_vec_len, data_len)
        }
        33 => wire__crate__api__ql__split_fw_update_into_chunks_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_backup_hash_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        2 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_data_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        3 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_next_chunk_index_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        4 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_seed_fingerprint_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_get_total_chunks_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_backup_hash_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        7 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_data_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        8 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_next_chunk_index_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_seed_fingerprint_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        10 => wire__crate__api__ql__CollectBackupChunks_auto_accessor_set_total_chunks_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        11 => wire__crate__api__ql__PrimeBackupFile_auto_accessor_get_data_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        12 => wire__crate__api__ql__PrimeBackupFile_auto_accessor_get_seed_fingerprint_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        13 => wire__crate__api__ql__PrimeBackupFile_auto_accessor_set_data_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__api__ql__PrimeBackupFile_auto_accessor_set_seed_fingerprint_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        26 => wire__crate__api__qr__greet_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<Mutex<Decoder>>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Arc<Mutex<Decoder>>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<Mutex<Decoder>>>> for Arc<Mutex<Decoder>> {
    fn into_into_dart(self) -> FrbWrapper<Arc<Mutex<Decoder>>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<CollectBackupChunks> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<CollectBackupChunks>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<CollectBackupChunks>> for CollectBackupChunks {
    fn into_into_dart(self) -> FrbWrapper<CollectBackupChunks> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EnvoyARIDCache> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EnvoyARIDCache> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EnvoyARIDCache>> for EnvoyARIDCache {
    fn into_into_dart(self) -> FrbWrapper<EnvoyARIDCache> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EnvoyMasterDechunker> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<EnvoyMasterDechunker>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EnvoyMasterDechunker>> for EnvoyMasterDechunker {
    fn into_into_dart(self) -> FrbWrapper<EnvoyMasterDechunker> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PrimeBackupFile> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PrimeBackupFile> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PrimeBackupFile>> for PrimeBackupFile {
    fn into_into_dart(self) -> FrbWrapper<PrimeBackupFile> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<QuantumLinkIdentity> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<QuantumLinkIdentity>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<QuantumLinkIdentity>> for QuantumLinkIdentity {
    fn into_into_dart(self) -> FrbWrapper<QuantumLinkIdentity> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<XIDDocument> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<XIDDocument> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<XIDDocument>> for XIDDocument {
    fn into_into_dart(self) -> FrbWrapper<XIDDocument> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::bitcoin::AccountUpdate> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.account_id.into_into_dart().into_dart(),
            self.0.update.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::bitcoin::AccountUpdate>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::bitcoin::AccountUpdate>>
    for foundation_api::api::bitcoin::AccountUpdate
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::bitcoin::AccountUpdate> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::bitcoin::ApplyPassphrase> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.fingerprint.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::bitcoin::ApplyPassphrase>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::bitcoin::ApplyPassphrase>>
    for foundation_api::api::bitcoin::ApplyPassphrase
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::bitcoin::ApplyPassphrase> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::backup::BackupChunk> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.chunk_index.into_into_dart().into_dart(),
            self.0.total_chunks.into_into_dart().into_dart(),
            self.0.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::BackupChunk>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::BackupChunk>>
    for foundation_api::api::backup::BackupChunk
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::BackupChunk> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::backup::BackupMetadata> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.total_chunks.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::BackupMetadata>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::BackupMetadata>>
    for foundation_api::api::backup::BackupMetadata
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::BackupMetadata> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::backup::BackupShardRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::BackupShardRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::BackupShardRequest>>
    for foundation_api::api::backup::BackupShardRequest
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::BackupShardRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::BackupShardResponse>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::backup::BackupShardResponse::Success => {
                [0.into_dart()].into_dart()
            }
            foundation_api::api::backup::BackupShardResponse::Error(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::BackupShardResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::BackupShardResponse>>
    for foundation_api::api::backup::BackupShardResponse
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::BackupShardResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::bitcoin::BroadcastTransaction>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.account_id.into_into_dart().into_dart(),
            self.0.psbt.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::bitcoin::BroadcastTransaction>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::bitcoin::BroadcastTransaction>,
    > for foundation_api::api::bitcoin::BroadcastTransaction
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::bitcoin::BroadcastTransaction> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::scv::ChallengeRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::scv::ChallengeRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::scv::ChallengeRequest>>
    for foundation_api::api::scv::ChallengeRequest
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::scv::ChallengeRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::scv::ChallengeResponseResult>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::scv::ChallengeResponseResult::Success { data } => {
                [0.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::scv::ChallengeResponseResult::Error { error } => {
                [1.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::scv::ChallengeResponseResult>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::scv::ChallengeResponseResult>>
    for foundation_api::api::scv::ChallengeResponseResult
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::scv::ChallengeResponseResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::CreateMagicBackupEvent>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::backup::CreateMagicBackupEvent::Start(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::backup::CreateMagicBackupEvent::Chunk(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::CreateMagicBackupEvent>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::CreateMagicBackupEvent>,
    > for foundation_api::api::backup::CreateMagicBackupEvent
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::CreateMagicBackupEvent> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::CreateMagicBackupResult>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::backup::CreateMagicBackupResult::Success => {
                [0.into_dart()].into_dart()
            }
            foundation_api::api::backup::CreateMagicBackupResult::Error(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::CreateMagicBackupResult>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::CreateMagicBackupResult>,
    > for foundation_api::api::backup::CreateMagicBackupResult
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::CreateMagicBackupResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::ql::DecoderStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.progress.into_into_dart().into_dart(),
            self.payload.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::ql::DecoderStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::ql::DecoderStatus>
    for crate::api::ql::DecoderStatus
{
    fn into_into_dart(self) -> crate::api::ql::DecoderStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::status::DeviceState> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::status::DeviceState::Normal => 0.into_dart(),
            foundation_api::api::status::DeviceState::UpdatingFirmware => 1.into_dart(),
            foundation_api::api::status::DeviceState::Rebooting => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::status::DeviceState>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::status::DeviceState>>
    for foundation_api::api::status::DeviceState
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::status::DeviceState> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::status::DeviceStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.state.into_into_dart().into_dart(),
            self.0.battery_level.into_into_dart().into_dart(),
            self.0.ble_signal.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::status::DeviceStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::status::DeviceStatus>>
    for foundation_api::api::status::DeviceStatus
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::status::DeviceStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledRequest>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledRequest>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledRequest>,
    > for foundation_api::api::backup::EnvoyMagicBackupEnabledRequest
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledResponse>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.enabled.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledResponse>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledResponse>,
    > for foundation_api::api::backup::EnvoyMagicBackupEnabledResponse
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<foundation_api::api::backup::EnvoyMagicBackupEnabledResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::message::EnvoyMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.message.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::message::EnvoyMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::message::EnvoyMessage>>
    for foundation_api::api::message::EnvoyMessage
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::message::EnvoyMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::status::EnvoyState> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::status::EnvoyState::Normal => 0.into_dart(),
            foundation_api::api::status::EnvoyState::DownloadingFirmware => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::status::EnvoyState>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::status::EnvoyState>>
    for foundation_api::api::status::EnvoyState
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::status::EnvoyState> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::status::EnvoyStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.state.into_into_dart().into_dart(),
            self.0.version.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::status::EnvoyStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::status::EnvoyStatus>>
    for foundation_api::api::status::EnvoyStatus
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::status::EnvoyStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::fx::ExchangeRate> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.currency_code.into_into_dart().into_dart(),
            self.0.rate.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::fx::ExchangeRate>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::fx::ExchangeRate>>
    for foundation_api::api::fx::ExchangeRate
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::fx::ExchangeRate> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::fx::ExchangeRateHistory> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.history.into_into_dart().into_dart(),
            self.0.currency_code.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::fx::ExchangeRateHistory>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::fx::ExchangeRateHistory>>
    for foundation_api::api::fx::ExchangeRateHistory
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::fx::ExchangeRateHistory> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::firmware::FirmwareChunk> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.patch_index.into_into_dart().into_dart(),
            self.0.total_patches.into_into_dart().into_dart(),
            self.0.chunk_index.into_into_dart().into_dart(),
            self.0.total_chunks.into_into_dart().into_dart(),
            self.0.data.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareChunk>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::firmware::FirmwareChunk>>
    for foundation_api::api::firmware::FirmwareChunk
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::firmware::FirmwareChunk> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::firmware::FirmwareFetchEvent>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::firmware::FirmwareFetchEvent::UpdateNotAvailable => {
                [0.into_dart()].into_dart()
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Starting(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Downloading => {
                [2.into_dart()].into_dart()
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Chunk(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Complete => {
                [4.into_dart()].into_dart()
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Error(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareFetchEvent>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::firmware::FirmwareFetchEvent>>
    for foundation_api::api::firmware::FirmwareFetchEvent
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::firmware::FirmwareFetchEvent> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::firmware::FirmwareFetchRequest>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.current_version.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareFetchRequest>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::firmware::FirmwareFetchRequest>,
    > for foundation_api::api::firmware::FirmwareFetchRequest
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::firmware::FirmwareFetchRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateAvailable>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.version.into_into_dart().into_dart(),
            self.0.changelog.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
            self.0.total_size.into_into_dart().into_dart(),
            self.0.patch_count.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateAvailable>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::firmware::FirmwareUpdateAvailable>,
    > for foundation_api::api::firmware::FirmwareUpdateAvailable
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::firmware::FirmwareUpdateAvailable> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckRequest>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.current_version.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckRequest>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckRequest>,
    > for foundation_api::api::firmware::FirmwareUpdateCheckRequest
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckResponse>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::firmware::FirmwareUpdateCheckResponse::Available(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::firmware::FirmwareUpdateCheckResponse::NotAvailable => {
                [1.into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckResponse>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckResponse>,
    > for foundation_api::api::firmware::FirmwareUpdateCheckResponse
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<foundation_api::api::firmware::FirmwareUpdateCheckResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateResult>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::firmware::FirmwareUpdateResult::Success { installed_version } => [
                0.into_dart(),
                installed_version.into_into_dart().into_dart(),
            ]
            .into_dart(),
            foundation_api::api::firmware::FirmwareUpdateResult::Error(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::firmware::FirmwareUpdateResult>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::firmware::FirmwareUpdateResult>,
    > for foundation_api::api::firmware::FirmwareUpdateResult
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::firmware::FirmwareUpdateResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::onboarding::OnboardingState>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::onboarding::OnboardingState::FirmwareUpdateScreen => 0.into_dart(),
            foundation_api::api::onboarding::OnboardingState::DownloadingUpdate => 1.into_dart(),
            foundation_api::api::onboarding::OnboardingState::ReceivingUpdate => 2.into_dart(),
            foundation_api::api::onboarding::OnboardingState::VeryfyingSignatures => 3.into_dart(),
            foundation_api::api::onboarding::OnboardingState::InstallingUpdate => 4.into_dart(),
            foundation_api::api::onboarding::OnboardingState::Rebooting => 5.into_dart(),
            foundation_api::api::onboarding::OnboardingState::FirmwareUpdated => 6.into_dart(),
            foundation_api::api::onboarding::OnboardingState::SecuringDevice => 7.into_dart(),
            foundation_api::api::onboarding::OnboardingState::DeviceSecured => 8.into_dart(),
            foundation_api::api::onboarding::OnboardingState::WalletCreationScreen => 9.into_dart(),
            foundation_api::api::onboarding::OnboardingState::CreatingWallet => 10.into_dart(),
            foundation_api::api::onboarding::OnboardingState::WalletCreated => 11.into_dart(),
            foundation_api::api::onboarding::OnboardingState::MagicBackupScreen => 12.into_dart(),
            foundation_api::api::onboarding::OnboardingState::CreatingMagicBackup => 13.into_dart(),
            foundation_api::api::onboarding::OnboardingState::MagicBackupCreated => 14.into_dart(),
            foundation_api::api::onboarding::OnboardingState::CreatingManualBackup => {
                15.into_dart()
            }
            foundation_api::api::onboarding::OnboardingState::CreatingKeycardBackup => {
                16.into_dart()
            }
            foundation_api::api::onboarding::OnboardingState::WritingDownSeedWords => {
                17.into_dart()
            }
            foundation_api::api::onboarding::OnboardingState::ConnectingWallet => 18.into_dart(),
            foundation_api::api::onboarding::OnboardingState::WalletConected => 19.into_dart(),
            foundation_api::api::onboarding::OnboardingState::Completed => 20.into_dart(),
            foundation_api::api::onboarding::OnboardingState::SecurityChecked => 21.into_dart(),
            foundation_api::api::onboarding::OnboardingState::UpdateAvailable => 22.into_dart(),
            foundation_api::api::onboarding::OnboardingState::UpdateNotAvailable => 23.into_dart(),
            foundation_api::api::onboarding::OnboardingState::SecurityCheckFailed => 24.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::onboarding::OnboardingState>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::onboarding::OnboardingState>>
    for foundation_api::api::onboarding::OnboardingState
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::onboarding::OnboardingState> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::pairing::PairingRequest> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.xid_document.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::pairing::PairingRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::pairing::PairingRequest>>
    for foundation_api::api::pairing::PairingRequest
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::pairing::PairingRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::pairing::PairingResponse> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.passport_model.into_into_dart().into_dart(),
            self.0
                .passport_firmware_version
                .into_into_dart()
                .into_dart(),
            self.0.passport_serial.into_into_dart().into_dart(),
            self.0.passport_color.into_into_dart().into_dart(),
            self.0.onboarding_complete.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::pairing::PairingResponse>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::pairing::PairingResponse>>
    for foundation_api::api::pairing::PairingResponse
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::pairing::PairingResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::passport::PassportColor> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::passport::PassportColor::Light => 0.into_dart(),
            foundation_api::api::passport::PassportColor::Dark => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::passport::PassportColor>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::passport::PassportColor>>
    for foundation_api::api::passport::PassportColor
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::passport::PassportColor> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::passport::PassportFirmwareVersion>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::passport::PassportFirmwareVersion>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::passport::PassportFirmwareVersion>,
    > for foundation_api::api::passport::PassportFirmwareVersion
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::passport::PassportFirmwareVersion> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::message::PassportMessage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.message.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::message::PassportMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::message::PassportMessage>>
    for foundation_api::api::message::PassportMessage
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::message::PassportMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::passport::PassportModel> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::passport::PassportModel::Gen1 => 0.into_dart(),
            foundation_api::api::passport::PassportModel::Gen2 => 1.into_dart(),
            foundation_api::api::passport::PassportModel::Prime => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::passport::PassportModel>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::passport::PassportModel>>
    for foundation_api::api::passport::PassportModel
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::passport::PassportModel> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::passport::PassportSerial> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::passport::PassportSerial>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::passport::PassportSerial>>
    for foundation_api::api::passport::PassportSerial
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::passport::PassportSerial> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::fx::PricePoint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.rate.into_into_dart().into_dart(),
            self.0.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::fx::PricePoint>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::fx::PricePoint>>
    for foundation_api::api::fx::PricePoint
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::fx::PricePoint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::PrimeMagicBackupEnabled>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.enabled.into_into_dart().into_dart(),
            self.0.seed_fingerprint.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::PrimeMagicBackupEnabled>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::PrimeMagicBackupEnabled>,
    > for foundation_api::api::backup::PrimeMagicBackupEnabled
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::PrimeMagicBackupEnabled> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusRequest>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.seed_fingerprint.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusRequest>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusRequest>,
    > for foundation_api::api::backup::PrimeMagicBackupStatusRequest
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusResponse>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.shard_backup_found.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusResponse>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusResponse>,
    > for foundation_api::api::backup::PrimeMagicBackupStatusResponse
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<foundation_api::api::backup::PrimeMagicBackupStatusResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::qr::QrDecoderStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.progress.into_into_dart().into_dart(),
            self.payload.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::qr::QrDecoderStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::qr::QrDecoderStatus>
    for crate::api::qr::QrDecoderStatus
{
    fn into_into_dart(self) -> crate::api::qr::QrDecoderStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::message::QuantumLinkMessage>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::message::QuantumLinkMessage::ExchangeRate(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::ExchangeRateHistory(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckRequest(
                field0,
            ) => [2.into_dart(), field0.into_into_dart().into_dart()].into_dart(),
            foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckResponse(
                field0,
            ) => [3.into_dart(), field0.into_into_dart().into_dart()].into_dart(),
            foundation_api::api::message::QuantumLinkMessage::FirmwareFetchRequest(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareFetchEvent(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateResult(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::DeviceStatus(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::EnvoyStatus(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::PairingRequest(field0) => {
                [9.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::PairingResponse(field0) => {
                [10.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::OnboardingState(field0) => {
                [11.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::SignPsbt(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::BroadcastTransaction(field0) => {
                [13.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::AccountUpdate(field0) => {
                [14.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::ApplyPassphrase(field0) => {
                [15.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::SecurityCheck(field0) => {
                [16.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledRequest(
                field0,
            ) => [17.into_dart(), field0.into_into_dart().into_dart()].into_dart(),
            foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledResponse(
                field0,
            ) => [18.into_dart(), field0.into_into_dart().into_dart()].into_dart(),
            foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupEnabled(field0) => {
                [19.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusRequest(
                field0,
            ) => [20.into_dart(), field0.into_into_dart().into_dart()].into_dart(),
            foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusResponse(
                field0,
            ) => [21.into_dart(), field0.into_into_dart().into_dart()].into_dart(),
            foundation_api::api::message::QuantumLinkMessage::BackupShardRequest(field0) => {
                [22.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::BackupShardResponse(field0) => {
                [23.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreShardRequest(field0) => {
                [24.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreShardResponse(field0) => {
                [25.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupEvent(field0) => {
                [26.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupResult(field0) => {
                [27.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupRequest(field0) => {
                [28.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupEvent(field0) => {
                [29.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupResult(field0) => {
                [30.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::message::QuantumLinkMessage::RawData(field0) => {
                [31.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::message::QuantumLinkMessage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::message::QuantumLinkMessage>>
    for foundation_api::api::message::QuantumLinkMessage
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::message::QuantumLinkMessage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::raw::RawData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payload.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::raw::RawData>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::raw::RawData>>
    for foundation_api::api::raw::RawData
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::raw::RawData> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::RestoreMagicBackupEvent>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::backup::RestoreMagicBackupEvent::NoBackupFound => {
                [0.into_dart()].into_dart()
            }
            foundation_api::api::backup::RestoreMagicBackupEvent::Starting(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::backup::RestoreMagicBackupEvent::Chunk(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::backup::RestoreMagicBackupEvent::Error(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::RestoreMagicBackupEvent>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::RestoreMagicBackupEvent>,
    > for foundation_api::api::backup::RestoreMagicBackupEvent
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::RestoreMagicBackupEvent> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::RestoreMagicBackupRequest>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.seed_fingerprint.into_into_dart().into_dart(),
            self.0.resume_from_chunk.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::RestoreMagicBackupRequest>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::RestoreMagicBackupRequest>,
    > for foundation_api::api::backup::RestoreMagicBackupRequest
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::RestoreMagicBackupRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::RestoreMagicBackupResult>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::backup::RestoreMagicBackupResult::Success => {
                [0.into_dart()].into_dart()
            }
            foundation_api::api::backup::RestoreMagicBackupResult::Error(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::RestoreMagicBackupResult>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<foundation_api::api::backup::RestoreMagicBackupResult>,
    > for foundation_api::api::backup::RestoreMagicBackupResult
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::RestoreMagicBackupResult> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::RestoreShardRequest>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.seed_fingerprint.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::RestoreShardRequest>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::RestoreShardRequest>>
    for foundation_api::api::backup::RestoreShardRequest
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::RestoreShardRequest> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<foundation_api::api::backup::RestoreShardResponse>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::backup::RestoreShardResponse::Success(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::backup::RestoreShardResponse::Error(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::backup::RestoreShardResponse::NotFound(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::RestoreShardResponse>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::RestoreShardResponse>>
    for foundation_api::api::backup::RestoreShardResponse
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::RestoreShardResponse> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::scv::SecurityCheck> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::scv::SecurityCheck::ChallengeRequest(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::scv::SecurityCheck::ChallengeResponse(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            foundation_api::api::scv::SecurityCheck::VerificationResult(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::scv::SecurityCheck>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::scv::SecurityCheck>>
    for foundation_api::api::scv::SecurityCheck
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::scv::SecurityCheck> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::backup::Shard> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.payload.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::Shard>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::Shard>>
    for foundation_api::api::backup::Shard
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::Shard> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::bitcoin::SignPsbt> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.account_id.into_into_dart().into_dart(),
            self.0.psbt.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::bitcoin::SignPsbt>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::bitcoin::SignPsbt>>
    for foundation_api::api::bitcoin::SignPsbt
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::bitcoin::SignPsbt> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::backup::StartMagicBackup> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.seed_fingerprint.into_into_dart().into_dart(),
            self.0.total_chunks.into_into_dart().into_dart(),
            self.0.hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::backup::StartMagicBackup>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::backup::StartMagicBackup>>
    for foundation_api::api::backup::StartMagicBackup
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::backup::StartMagicBackup> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<foundation_api::api::scv::VerificationResult> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            foundation_api::api::scv::VerificationResult::Success => [0.into_dart()].into_dart(),
            foundation_api::api::scv::VerificationResult::Error { error } => {
                [1.into_dart(), error.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<foundation_api::api::scv::VerificationResult>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<foundation_api::api::scv::VerificationResult>>
    for foundation_api::api::scv::VerificationResult
{
    fn into_into_dart(self) -> FrbWrapper<foundation_api::api::scv::VerificationResult> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for Arc<Mutex<Decoder>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Decoder > >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for CollectBackupChunks {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EnvoyARIDCache {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EnvoyMasterDechunker {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for PrimeBackupFile {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for QuantumLinkIdentity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for XIDDocument {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<Mutex<Decoder>>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for foundation_api::api::bitcoin::AccountUpdate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.account_id, serializer);
        <Vec<u8>>::sse_encode(self.update, serializer);
    }
}

impl SseEncode for foundation_api::api::bitcoin::ApplyPassphrase {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.fingerprint, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::BackupChunk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.chunk_index, serializer);
        <u32>::sse_encode(self.total_chunks, serializer);
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::BackupMetadata {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.total_chunks, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::BackupShardRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <foundation_api::api::backup::Shard>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::BackupShardResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::backup::BackupShardResponse::Success => {
                <i32>::sse_encode(0, serializer);
            }
            foundation_api::api::backup::BackupShardResponse::Error(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for foundation_api::api::bitcoin::BroadcastTransaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.account_id, serializer);
        <Vec<u8>>::sse_encode(self.psbt, serializer);
    }
}

impl SseEncode for foundation_api::api::scv::ChallengeRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for foundation_api::api::scv::ChallengeResponseResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::scv::ChallengeResponseResult::Success { data } => {
                <i32>::sse_encode(0, serializer);
                <Vec<u8>>::sse_encode(data, serializer);
            }
            foundation_api::api::scv::ChallengeResponseResult::Error { error } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::backup::CreateMagicBackupEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::backup::CreateMagicBackupEvent::Start(field0) => {
                <i32>::sse_encode(0, serializer);
                <foundation_api::api::backup::StartMagicBackup>::sse_encode(field0, serializer);
            }
            foundation_api::api::backup::CreateMagicBackupEvent::Chunk(field0) => {
                <i32>::sse_encode(1, serializer);
                <foundation_api::api::backup::BackupChunk>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::backup::CreateMagicBackupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::backup::CreateMagicBackupResult::Success => {
                <i32>::sse_encode(0, serializer);
            }
            foundation_api::api::backup::CreateMagicBackupResult::Error(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::ql::DecoderStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.progress, serializer);
        <Option<foundation_api::api::message::PassportMessage>>::sse_encode(
            self.payload,
            serializer,
        );
    }
}

impl SseEncode for foundation_api::api::status::DeviceState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                foundation_api::api::status::DeviceState::Normal => 0,
                foundation_api::api::status::DeviceState::UpdatingFirmware => 1,
                foundation_api::api::status::DeviceState::Rebooting => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for foundation_api::api::status::DeviceStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <foundation_api::api::status::DeviceState>::sse_encode(self.state, serializer);
        <u8>::sse_encode(self.battery_level, serializer);
        <i8>::sse_encode(self.ble_signal, serializer);
        <String>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::EnvoyMagicBackupEnabledRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for foundation_api::api::backup::EnvoyMagicBackupEnabledResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.enabled, serializer);
    }
}

impl SseEncode for foundation_api::api::message::EnvoyMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <foundation_api::api::message::QuantumLinkMessage>::sse_encode(self.message, serializer);
        <u32>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for foundation_api::api::status::EnvoyState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                foundation_api::api::status::EnvoyState::Normal => 0,
                foundation_api::api::status::EnvoyState::DownloadingFirmware => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for foundation_api::api::status::EnvoyStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <foundation_api::api::status::EnvoyState>::sse_encode(self.state, serializer);
        <String>::sse_encode(self.version, serializer);
    }
}

impl SseEncode for foundation_api::api::fx::ExchangeRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.currency_code, serializer);
        <f32>::sse_encode(self.rate, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for foundation_api::api::fx::ExchangeRateHistory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<foundation_api::api::fx::PricePoint>>::sse_encode(self.history, serializer);
        <String>::sse_encode(self.currency_code, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareChunk {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.patch_index, serializer);
        <u8>::sse_encode(self.total_patches, serializer);
        <u16>::sse_encode(self.chunk_index, serializer);
        <u16>::sse_encode(self.total_chunks, serializer);
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareFetchEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::firmware::FirmwareFetchEvent::UpdateNotAvailable => {
                <i32>::sse_encode(0, serializer);
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Starting(field0) => {
                <i32>::sse_encode(1, serializer);
                <foundation_api::api::firmware::FirmwareUpdateAvailable>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Downloading => {
                <i32>::sse_encode(2, serializer);
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Chunk(field0) => {
                <i32>::sse_encode(3, serializer);
                <foundation_api::api::firmware::FirmwareChunk>::sse_encode(field0, serializer);
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Complete => {
                <i32>::sse_encode(4, serializer);
            }
            foundation_api::api::firmware::FirmwareFetchEvent::Error(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareFetchRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.current_version, serializer);
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareUpdateAvailable {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.version, serializer);
        <String>::sse_encode(self.changelog, serializer);
        <u32>::sse_encode(self.timestamp, serializer);
        <u32>::sse_encode(self.total_size, serializer);
        <u8>::sse_encode(self.patch_count, serializer);
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareUpdateCheckRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.current_version, serializer);
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareUpdateCheckResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::firmware::FirmwareUpdateCheckResponse::Available(field0) => {
                <i32>::sse_encode(0, serializer);
                <foundation_api::api::firmware::FirmwareUpdateAvailable>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::firmware::FirmwareUpdateCheckResponse::NotAvailable => {
                <i32>::sse_encode(1, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::firmware::FirmwareUpdateResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::firmware::FirmwareUpdateResult::Success { installed_version } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(installed_version, serializer);
            }
            foundation_api::api::firmware::FirmwareUpdateResult::Error(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i8(self).unwrap();
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<foundation_api::api::fx::PricePoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <foundation_api::api::fx::PricePoint>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<foundation_api::api::message::QuantumLinkMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <foundation_api::api::message::QuantumLinkMessage>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for foundation_api::api::onboarding::OnboardingState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                foundation_api::api::onboarding::OnboardingState::FirmwareUpdateScreen => 0,
                foundation_api::api::onboarding::OnboardingState::DownloadingUpdate => 1,
                foundation_api::api::onboarding::OnboardingState::ReceivingUpdate => 2,
                foundation_api::api::onboarding::OnboardingState::VeryfyingSignatures => 3,
                foundation_api::api::onboarding::OnboardingState::InstallingUpdate => 4,
                foundation_api::api::onboarding::OnboardingState::Rebooting => 5,
                foundation_api::api::onboarding::OnboardingState::FirmwareUpdated => 6,
                foundation_api::api::onboarding::OnboardingState::SecuringDevice => 7,
                foundation_api::api::onboarding::OnboardingState::DeviceSecured => 8,
                foundation_api::api::onboarding::OnboardingState::WalletCreationScreen => 9,
                foundation_api::api::onboarding::OnboardingState::CreatingWallet => 10,
                foundation_api::api::onboarding::OnboardingState::WalletCreated => 11,
                foundation_api::api::onboarding::OnboardingState::MagicBackupScreen => 12,
                foundation_api::api::onboarding::OnboardingState::CreatingMagicBackup => 13,
                foundation_api::api::onboarding::OnboardingState::MagicBackupCreated => 14,
                foundation_api::api::onboarding::OnboardingState::CreatingManualBackup => 15,
                foundation_api::api::onboarding::OnboardingState::CreatingKeycardBackup => 16,
                foundation_api::api::onboarding::OnboardingState::WritingDownSeedWords => 17,
                foundation_api::api::onboarding::OnboardingState::ConnectingWallet => 18,
                foundation_api::api::onboarding::OnboardingState::WalletConected => 19,
                foundation_api::api::onboarding::OnboardingState::Completed => 20,
                foundation_api::api::onboarding::OnboardingState::SecurityChecked => 21,
                foundation_api::api::onboarding::OnboardingState::UpdateAvailable => 22,
                foundation_api::api::onboarding::OnboardingState::UpdateNotAvailable => 23,
                foundation_api::api::onboarding::OnboardingState::SecurityCheckFailed => 24,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<PrimeBackupFile> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <PrimeBackupFile>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<XIDDocument> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <XIDDocument>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<foundation_api::api::message::PassportMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <foundation_api::api::message::PassportMessage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for foundation_api::api::pairing::PairingRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.xid_document, serializer);
    }
}

impl SseEncode for foundation_api::api::pairing::PairingResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <foundation_api::api::passport::PassportModel>::sse_encode(self.passport_model, serializer);
        <foundation_api::api::passport::PassportFirmwareVersion>::sse_encode(
            self.passport_firmware_version,
            serializer,
        );
        <foundation_api::api::passport::PassportSerial>::sse_encode(
            self.passport_serial,
            serializer,
        );
        <foundation_api::api::passport::PassportColor>::sse_encode(self.passport_color, serializer);
        <bool>::sse_encode(self.onboarding_complete, serializer);
    }
}

impl SseEncode for foundation_api::api::passport::PassportColor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                foundation_api::api::passport::PassportColor::Light => 0,
                foundation_api::api::passport::PassportColor::Dark => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for foundation_api::api::passport::PassportFirmwareVersion {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for foundation_api::api::message::PassportMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <foundation_api::api::message::QuantumLinkMessage>::sse_encode(self.message, serializer);
        <foundation_api::api::status::DeviceStatus>::sse_encode(self.status, serializer);
    }
}

impl SseEncode for foundation_api::api::passport::PassportModel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                foundation_api::api::passport::PassportModel::Gen1 => 0,
                foundation_api::api::passport::PassportModel::Gen2 => 1,
                foundation_api::api::passport::PassportModel::Prime => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for foundation_api::api::passport::PassportSerial {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for foundation_api::api::fx::PricePoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.rate, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::PrimeMagicBackupEnabled {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.enabled, serializer);
        <[u8; 32]>::sse_encode(self.seed_fingerprint, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::PrimeMagicBackupStatusRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.seed_fingerprint, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::PrimeMagicBackupStatusResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.shard_backup_found, serializer);
    }
}

impl SseEncode for crate::api::qr::QrDecoderStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.progress, serializer);
        <Option<XIDDocument>>::sse_encode(self.payload, serializer);
    }
}

impl SseEncode for foundation_api::api::message::QuantumLinkMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::message::QuantumLinkMessage::ExchangeRate(field0) => {
                <i32>::sse_encode(0, serializer);
                <foundation_api::api::fx::ExchangeRate>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::ExchangeRateHistory(field0) => {
                <i32>::sse_encode(1, serializer);
                <foundation_api::api::fx::ExchangeRateHistory>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckRequest(
                field0,
            ) => {
                <i32>::sse_encode(2, serializer);
                <foundation_api::api::firmware::FirmwareUpdateCheckRequest>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateCheckResponse(
                field0,
            ) => {
                <i32>::sse_encode(3, serializer);
                <foundation_api::api::firmware::FirmwareUpdateCheckResponse>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareFetchRequest(field0) => {
                <i32>::sse_encode(4, serializer);
                <foundation_api::api::firmware::FirmwareFetchRequest>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareFetchEvent(field0) => {
                <i32>::sse_encode(5, serializer);
                <foundation_api::api::firmware::FirmwareFetchEvent>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::FirmwareUpdateResult(field0) => {
                <i32>::sse_encode(6, serializer);
                <foundation_api::api::firmware::FirmwareUpdateResult>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::DeviceStatus(field0) => {
                <i32>::sse_encode(7, serializer);
                <foundation_api::api::status::DeviceStatus>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::EnvoyStatus(field0) => {
                <i32>::sse_encode(8, serializer);
                <foundation_api::api::status::EnvoyStatus>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::PairingRequest(field0) => {
                <i32>::sse_encode(9, serializer);
                <foundation_api::api::pairing::PairingRequest>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::PairingResponse(field0) => {
                <i32>::sse_encode(10, serializer);
                <foundation_api::api::pairing::PairingResponse>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::OnboardingState(field0) => {
                <i32>::sse_encode(11, serializer);
                <foundation_api::api::onboarding::OnboardingState>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::SignPsbt(field0) => {
                <i32>::sse_encode(12, serializer);
                <foundation_api::api::bitcoin::SignPsbt>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::BroadcastTransaction(field0) => {
                <i32>::sse_encode(13, serializer);
                <foundation_api::api::bitcoin::BroadcastTransaction>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::AccountUpdate(field0) => {
                <i32>::sse_encode(14, serializer);
                <foundation_api::api::bitcoin::AccountUpdate>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::ApplyPassphrase(field0) => {
                <i32>::sse_encode(15, serializer);
                <foundation_api::api::bitcoin::ApplyPassphrase>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::SecurityCheck(field0) => {
                <i32>::sse_encode(16, serializer);
                <foundation_api::api::scv::SecurityCheck>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledRequest(
                field0,
            ) => {
                <i32>::sse_encode(17, serializer);
                <foundation_api::api::backup::EnvoyMagicBackupEnabledRequest>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::EnvoyMagicBackupEnabledResponse(
                field0,
            ) => {
                <i32>::sse_encode(18, serializer);
                <foundation_api::api::backup::EnvoyMagicBackupEnabledResponse>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupEnabled(field0) => {
                <i32>::sse_encode(19, serializer);
                <foundation_api::api::backup::PrimeMagicBackupEnabled>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusRequest(
                field0,
            ) => {
                <i32>::sse_encode(20, serializer);
                <foundation_api::api::backup::PrimeMagicBackupStatusRequest>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::PrimeMagicBackupStatusResponse(
                field0,
            ) => {
                <i32>::sse_encode(21, serializer);
                <foundation_api::api::backup::PrimeMagicBackupStatusResponse>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::BackupShardRequest(field0) => {
                <i32>::sse_encode(22, serializer);
                <foundation_api::api::backup::BackupShardRequest>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::BackupShardResponse(field0) => {
                <i32>::sse_encode(23, serializer);
                <foundation_api::api::backup::BackupShardResponse>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreShardRequest(field0) => {
                <i32>::sse_encode(24, serializer);
                <foundation_api::api::backup::RestoreShardRequest>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreShardResponse(field0) => {
                <i32>::sse_encode(25, serializer);
                <foundation_api::api::backup::RestoreShardResponse>::sse_encode(field0, serializer);
            }
            foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupEvent(field0) => {
                <i32>::sse_encode(26, serializer);
                <foundation_api::api::backup::CreateMagicBackupEvent>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::CreateMagicBackupResult(field0) => {
                <i32>::sse_encode(27, serializer);
                <foundation_api::api::backup::CreateMagicBackupResult>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupRequest(field0) => {
                <i32>::sse_encode(28, serializer);
                <foundation_api::api::backup::RestoreMagicBackupRequest>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupEvent(field0) => {
                <i32>::sse_encode(29, serializer);
                <foundation_api::api::backup::RestoreMagicBackupEvent>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::RestoreMagicBackupResult(field0) => {
                <i32>::sse_encode(30, serializer);
                <foundation_api::api::backup::RestoreMagicBackupResult>::sse_encode(
                    field0, serializer,
                );
            }
            foundation_api::api::message::QuantumLinkMessage::RawData(field0) => {
                <i32>::sse_encode(31, serializer);
                <foundation_api::api::raw::RawData>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::raw::RawData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.payload, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::RestoreMagicBackupEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::backup::RestoreMagicBackupEvent::NoBackupFound => {
                <i32>::sse_encode(0, serializer);
            }
            foundation_api::api::backup::RestoreMagicBackupEvent::Starting(field0) => {
                <i32>::sse_encode(1, serializer);
                <foundation_api::api::backup::BackupMetadata>::sse_encode(field0, serializer);
            }
            foundation_api::api::backup::RestoreMagicBackupEvent::Chunk(field0) => {
                <i32>::sse_encode(2, serializer);
                <foundation_api::api::backup::BackupChunk>::sse_encode(field0, serializer);
            }
            foundation_api::api::backup::RestoreMagicBackupEvent::Error(field0) => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::backup::RestoreMagicBackupRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.seed_fingerprint, serializer);
        <u32>::sse_encode(self.resume_from_chunk, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::RestoreMagicBackupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::backup::RestoreMagicBackupResult::Success => {
                <i32>::sse_encode(0, serializer);
            }
            foundation_api::api::backup::RestoreMagicBackupResult::Error(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::backup::RestoreShardRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.seed_fingerprint, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::RestoreShardResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::backup::RestoreShardResponse::Success(field0) => {
                <i32>::sse_encode(0, serializer);
                <foundation_api::api::backup::Shard>::sse_encode(field0, serializer);
            }
            foundation_api::api::backup::RestoreShardResponse::Error(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            foundation_api::api::backup::RestoreShardResponse::NotFound(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::scv::SecurityCheck {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::scv::SecurityCheck::ChallengeRequest(field0) => {
                <i32>::sse_encode(0, serializer);
                <foundation_api::api::scv::ChallengeRequest>::sse_encode(field0, serializer);
            }
            foundation_api::api::scv::SecurityCheck::ChallengeResponse(field0) => {
                <i32>::sse_encode(1, serializer);
                <foundation_api::api::scv::ChallengeResponseResult>::sse_encode(field0, serializer);
            }
            foundation_api::api::scv::SecurityCheck::VerificationResult(field0) => {
                <i32>::sse_encode(2, serializer);
                <foundation_api::api::scv::VerificationResult>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for foundation_api::api::backup::Shard {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.payload, serializer);
    }
}

impl SseEncode for foundation_api::api::bitcoin::SignPsbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.account_id, serializer);
        <Vec<u8>>::sse_encode(self.psbt, serializer);
    }
}

impl SseEncode for foundation_api::api::backup::StartMagicBackup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.seed_fingerprint, serializer);
        <u32>::sse_encode(self.total_chunks, serializer);
        <[u8; 32]>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for foundation_api::api::scv::VerificationResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            foundation_api::api::scv::VerificationResult::Success => {
                <i32>::sse_encode(0, serializer);
            }
            foundation_api::api::scv::VerificationResult::Error { error } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(error, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::ql::*;
    use crate::api::qr::*;
    use bc_xid::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};
    use foundation_api::api::quantum_link::*;

    // Section: boilerplate

    use btp::Dechunker;
    use foundation_ur::Decoder;
    use std::sync::Mutex;

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexDecoder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Decoder > >>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexDecoder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Decoder > >>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCollectBackupChunks(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCollectBackupChunks(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyARIDCache(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyARIDCache(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyMasterDechunker(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyMasterDechunker(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPrimeBackupFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPrimeBackupFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQuantumLinkIdentity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQuantumLinkIdentity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerXIDDocument(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_foundation_api_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerXIDDocument(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::ql::*;
    use crate::api::qr::*;
    use bc_xid::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};
    use foundation_api::api::quantum_link::*;

    // Section: boilerplate

    use btp::Dechunker;
    use foundation_ur::Decoder;
    use std::sync::Mutex;

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexDecoder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Decoder > >>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexDecoder(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Decoder > >>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCollectBackupChunks(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCollectBackupChunks(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CollectBackupChunks>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyARIDCache(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyARIDCache(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyARIDCache>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyMasterDechunker(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyMasterDechunker(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyMasterDechunker>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPrimeBackupFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPrimeBackupFile(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrimeBackupFile>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQuantumLinkIdentity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQuantumLinkIdentity(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QuantumLinkIdentity>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerXIDDocument(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerXIDDocument(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XIDDocument>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
