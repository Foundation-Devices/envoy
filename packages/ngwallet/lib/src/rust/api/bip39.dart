// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../third_party/ngwallet/config.dart';
import 'envoy_wallet.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `generate_mnemonic`

class DescriptorFromSeed {
  final String externalDescriptor;
  final String internalDescriptor;
  final String externalPubDescriptor;
  final String internalPubDescriptor;

  const DescriptorFromSeed({
    required this.externalDescriptor,
    required this.internalDescriptor,
    required this.externalPubDescriptor,
    required this.internalPubDescriptor,
  });

  @override
  int get hashCode =>
      externalDescriptor.hashCode ^
      internalDescriptor.hashCode ^
      externalPubDescriptor.hashCode ^
      internalPubDescriptor.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DescriptorFromSeed &&
          runtimeType == other.runtimeType &&
          externalDescriptor == other.externalDescriptor &&
          internalDescriptor == other.internalDescriptor &&
          externalPubDescriptor == other.externalPubDescriptor &&
          internalPubDescriptor == other.internalPubDescriptor;
}

class EnvoyBip39 {
  const EnvoyBip39();

  static Future<DescriptorFromSeed> deriveDescriptorFromSeed(
          {required String seedWords,
          required Network network,
          required AddressType addressType,
          required String derivationPath,
          String? passphrase}) =>
      RustLib.instance.api.crateApiBip39EnvoyBip39DeriveDescriptorFromSeed(
          seedWords: seedWords,
          network: network,
          addressType: addressType,
          derivationPath: derivationPath,
          passphrase: passphrase);

  static Future<Seed> generateSeed({required Network network}) =>
      RustLib.instance.api
          .crateApiBip39EnvoyBip39GenerateSeed(network: network);

  static Future<bool> validateSeed({required String seedWords}) =>
      RustLib.instance.api
          .crateApiBip39EnvoyBip39ValidateSeed(seedWords: seedWords);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EnvoyBip39 && runtimeType == other.runtimeType;
}

class Seed {
  final String mnemonic;
  final String xprv;
  final String fingerprint;

  const Seed({
    required this.mnemonic,
    required this.xprv,
    required this.fingerprint,
  });

  @override
  int get hashCode => mnemonic.hashCode ^ xprv.hashCode ^ fingerprint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Seed &&
          runtimeType == other.runtimeType &&
          mnemonic == other.mnemonic &&
          xprv == other.xprv &&
          fingerprint == other.fingerprint;
}
