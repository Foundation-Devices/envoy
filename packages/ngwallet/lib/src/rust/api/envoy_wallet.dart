// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../third_party/ngwallet/config.dart';
import '../third_party/ngwallet/transaction.dart';
import 'envoy_account.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Option < FullScanRequest < KeychainKind > > > >>>
abstract class FullScanRequest implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Option < SyncRequest < (KeychainKind , u32) > > > >>>
abstract class SyncRequest implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Update > >>>
abstract class WalletUpdate implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyAccountHandler>>
abstract class EnvoyAccountHandler implements RustOpaqueInterface {
  Future<bool> applyUpdate({required WalletUpdate update});

  ArcMutexNgAccountConnection get ngAccount;

  RustStreamSink<EnvoyAccount>? get streamSink;

  set ngAccount(ArcMutexNgAccountConnection ngAccount);

  set streamSink(RustStreamSink<EnvoyAccount>? streamSink);

  BigInt balance();

  Future<void> broadcast(
      {required String psbt, required String electrumServer});

  NgAccountConfig config();

  bool isHot();

  static Future<EnvoyAccountHandler> migrate(
          {required String name,
          required String id,
          String? deviceSerial,
          String? dateAdded,
          required AddressType addressType,
          required String color,
          required int index,
          required String internalDescriptor,
          required String externalDescriptor,
          required String dbPath,
          required String sledDbPath,
          required Network network}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerMigrate(
          name: name,
          id: id,
          deviceSerial: deviceSerial,
          dateAdded: dateAdded,
          addressType: addressType,
          color: color,
          index: index,
          internalDescriptor: internalDescriptor,
          externalDescriptor: externalDescriptor,
          dbPath: dbPath,
          sledDbPath: sledDbPath,
          network: network);

  static Future<EnvoyAccountHandler> newFromDescriptor(
          {required String name,
          String? deviceSerial,
          String? dateAdded,
          required AddressType addressType,
          required String color,
          required int index,
          required String internalDescriptor,
          required String externalDescriptor,
          required String dbPath,
          required Network network,
          required String id}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerNewFromDescriptor(
              name: name,
              deviceSerial: deviceSerial,
              dateAdded: dateAdded,
              addressType: addressType,
              color: color,
              index: index,
              internalDescriptor: internalDescriptor,
              externalDescriptor: externalDescriptor,
              dbPath: dbPath,
              network: network,
              id: id);

  Future<String> nextAddress();

  static Future<EnvoyAccountHandler> openWallet({required String dbPath}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerOpenWallet(dbPath: dbPath);

  Future<void> renameAccount({required String name});

  Future<FullScanRequest> requestFullScan();

  Future<SyncRequest> requestSync();

  static Future<WalletUpdate> scan(
          {required FullScanRequest scanRequest,
          required String electrumServer,
          int? torPort}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerScan(
          scanRequest: scanRequest,
          electrumServer: electrumServer,
          torPort: torPort);

  Future<String> send({required String address, required BigInt amount});

  Future<void> sendUpdate();

  Future<bool> setDoNotSpend({required Output utxo, required bool doNotSpend});

  Future<bool> setNote({required String txId, required String note});

  Future<bool> setTag({required Output utxo, required String tag});

  Future<EnvoyAccount> state();

  Stream<EnvoyAccount> stream();

  static Future<WalletUpdate> syncWallet(
          {required SyncRequest syncRequest,
          required String electrumServer,
          int? torPort}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSyncWallet(
          syncRequest: syncRequest,
          electrumServer: electrumServer,
          torPort: torPort);

  Future<List<BitcoinTransaction>> transactions();

  Future<List<Output>> utxo();

  static Future<bool> validateAddress(
          {required String address, Network? network}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerValidateAddress(
              address: address, network: network);
}

enum Network {
  /// Mainnet Bitcoin.
  bitcoin,

  /// Bitcoin's testnet network. (In future versions this will be combined
  /// into a single variant containing the version)
  testnet,

  /// Bitcoin's testnet4 network. (In future versions this will be combined
  /// into a single variant containing the version)
  testnet4,

  /// Bitcoin's signet network.
  signet,

  /// Bitcoin's regtest network.
  regtest,
  ;
}
