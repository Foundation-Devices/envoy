// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../third_party/ngwallet/config.dart';
import '../third_party/ngwallet/rbf.dart';
import '../third_party/ngwallet/send.dart';
import '../third_party/ngwallet/transaction.dart';
import 'envoy_account.dart';
import 'errors.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Option < FullScanRequest < KeychainKind > > > >>>
abstract class FullScanRequest implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Option < SyncRequest < (KeychainKind , u32) > > > >>>
abstract class SyncRequest implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Mutex < Update > >>>
abstract class WalletUpdate implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EnvoyAccountHandler>>
abstract class EnvoyAccountHandler implements RustOpaqueInterface {
  Future<void> applyUpdate({required WalletUpdate update});

  ArcMutexNgAccountConnection get ngAccount;

  RustStreamSink<EnvoyAccount>? get streamSink;

  set ngAccount(ArcMutexNgAccountConnection ngAccount);

  set streamSink(RustStreamSink<EnvoyAccount>? streamSink);

  BigInt balance();

  static Future<String> broadcast(
          {required DraftTransaction draftTransaction,
          required String electrumServer,
          int? torPort}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerBroadcast(
          draftTransaction: draftTransaction,
          electrumServer: electrumServer,
          torPort: torPort);

  Future<DraftTransaction> composeCancellationTx(
      {required BitcoinTransaction bitcoinTransaction});

  Future<DraftTransaction> composePsbt(
      {required TransactionParams transactionParams});

  Future<DraftTransaction> composeRbfPsbt(
      {required List<Output> selectedOutputs,
      required BigInt feeRate,
      required BitcoinTransaction bitcoinTransaction});

  NgAccountConfig config();

  static Future<DraftTransaction> decodePsbt(
          {required DraftTransaction draftTransaction,
          required String psbtBase64}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerDecodePsbt(
          draftTransaction: draftTransaction, psbtBase64: psbtBase64);

  Future<TransactionFeeResult> getMaxBumpFeeRates(
      {required List<Output> selectedOutputs,
      required BitcoinTransaction bitcoinTransaction});

  Future<TransactionFeeResult> getMaxFee(
      {required TransactionParams transactionParams});

  String id();

  bool isHot();

  static Future<EnvoyAccountHandler> migrate(
          {required String name,
          required String id,
          String? deviceSerial,
          String? dateAdded,
          required AddressType addressType,
          required String color,
          required int index,
          required String internalDescriptor,
          required String externalDescriptor,
          required String dbPath,
          required String sledDbPath,
          required Network network}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerMigrate(
          name: name,
          id: id,
          deviceSerial: deviceSerial,
          dateAdded: dateAdded,
          addressType: addressType,
          color: color,
          index: index,
          internalDescriptor: internalDescriptor,
          externalDescriptor: externalDescriptor,
          dbPath: dbPath,
          sledDbPath: sledDbPath,
          network: network);

  static Future<EnvoyAccountHandler> newFromDescriptor(
          {required String name,
          String? deviceSerial,
          String? dateAdded,
          required AddressType addressType,
          required String color,
          required int index,
          required String internalDescriptor,
          required String externalDescriptor,
          required String dbPath,
          required Network network,
          required String id}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerNewFromDescriptor(
              name: name,
              deviceSerial: deviceSerial,
              dateAdded: dateAdded,
              addressType: addressType,
              color: color,
              index: index,
              internalDescriptor: internalDescriptor,
              externalDescriptor: externalDescriptor,
              dbPath: dbPath,
              network: network,
              id: id);

  Future<String> nextAddress();

  static Future<EnvoyAccountHandler> openWallet({required String dbPath}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerOpenWallet(dbPath: dbPath);

  Future<void> renameAccount({required String name});

  Future<void> renameTag({required String existingTag, String? newTag});

  Future<FullScanRequest> requestFullScan();

  Future<SyncRequest> requestSync();

  static Future<WalletUpdate> scan(
          {required FullScanRequest scanRequest,
          required String electrumServer,
          int? torPort}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerScan(
          scanRequest: scanRequest,
          electrumServer: electrumServer,
          torPort: torPort);

  Future<String> send({required String address, required BigInt amount});

  Future<void> sendUpdate();

  Future<bool> setDoNotSpend({required Output utxo, required bool doNotSpend});

  Future<void> setDoNotSpendMultiple(
      {required List<String> utxo, required bool doNotSpend});

  Future<bool> setNote({required String txId, required String note});

  Future<bool> setTag({required Output utxo, required String tag});

  Future<void> setTagMultiple(
      {required List<String> utxo, required String tag});

  Future<bool> setTags({required List<Output> utxo, required String tag});

  Future<EnvoyAccount> state();

  Stream<EnvoyAccount> stream();

  static Future<WalletUpdate> syncWallet(
          {required SyncRequest syncRequest,
          required String electrumServer,
          int? torPort}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSyncWallet(
          syncRequest: syncRequest,
          electrumServer: electrumServer,
          torPort: torPort);

  Future<List<BitcoinTransaction>> transactions();

  Future<void> updateBroadcastState(
      {required DraftTransaction draftTransaction});

  Future<List<Output>> utxo();

  static Future<bool> validateAddress(
          {required String address, Network? network}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerValidateAddress(
              address: address, network: network);
}

enum Network {
  /// Mainnet Bitcoin.
  bitcoin,

  /// Bitcoin's testnet network. (In future versions this will be combined
  /// into a single variant containing the version)
  testnet,

  /// Bitcoin's testnet4 network. (In future versions this will be combined
  /// into a single variant containing the version)
  testnet4,

  /// Bitcoin's signet network.
  signet,

  /// Bitcoin's regtest network.
  regtest,
  ;
}
