// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'errors.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BroadcastError {
  String get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) networkError,
    required TResult Function(String field0) consensusError,
    required TResult Function(String field0) message,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? networkError,
    TResult? Function(String field0)? consensusError,
    TResult? Function(String field0)? message,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? networkError,
    TResult Function(String field0)? consensusError,
    TResult Function(String field0)? message,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BroadcastError_NetworkError value) networkError,
    required TResult Function(BroadcastError_ConsensusError value)
        consensusError,
    required TResult Function(BroadcastError_Message value) message,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BroadcastError_NetworkError value)? networkError,
    TResult? Function(BroadcastError_ConsensusError value)? consensusError,
    TResult? Function(BroadcastError_Message value)? message,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BroadcastError_NetworkError value)? networkError,
    TResult Function(BroadcastError_ConsensusError value)? consensusError,
    TResult Function(BroadcastError_Message value)? message,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BroadcastErrorCopyWith<BroadcastError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BroadcastErrorCopyWith<$Res> {
  factory $BroadcastErrorCopyWith(
          BroadcastError value, $Res Function(BroadcastError) then) =
      _$BroadcastErrorCopyWithImpl<$Res, BroadcastError>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class _$BroadcastErrorCopyWithImpl<$Res, $Val extends BroadcastError>
    implements $BroadcastErrorCopyWith<$Res> {
  _$BroadcastErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BroadcastError_NetworkErrorImplCopyWith<$Res>
    implements $BroadcastErrorCopyWith<$Res> {
  factory _$$BroadcastError_NetworkErrorImplCopyWith(
          _$BroadcastError_NetworkErrorImpl value,
          $Res Function(_$BroadcastError_NetworkErrorImpl) then) =
      __$$BroadcastError_NetworkErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BroadcastError_NetworkErrorImplCopyWithImpl<$Res>
    extends _$BroadcastErrorCopyWithImpl<$Res,
        _$BroadcastError_NetworkErrorImpl>
    implements _$$BroadcastError_NetworkErrorImplCopyWith<$Res> {
  __$$BroadcastError_NetworkErrorImplCopyWithImpl(
      _$BroadcastError_NetworkErrorImpl _value,
      $Res Function(_$BroadcastError_NetworkErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BroadcastError_NetworkErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BroadcastError_NetworkErrorImpl extends BroadcastError_NetworkError {
  const _$BroadcastError_NetworkErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'BroadcastError.networkError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BroadcastError_NetworkErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BroadcastError_NetworkErrorImplCopyWith<_$BroadcastError_NetworkErrorImpl>
      get copyWith => __$$BroadcastError_NetworkErrorImplCopyWithImpl<
          _$BroadcastError_NetworkErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) networkError,
    required TResult Function(String field0) consensusError,
    required TResult Function(String field0) message,
  }) {
    return networkError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? networkError,
    TResult? Function(String field0)? consensusError,
    TResult? Function(String field0)? message,
  }) {
    return networkError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? networkError,
    TResult Function(String field0)? consensusError,
    TResult Function(String field0)? message,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BroadcastError_NetworkError value) networkError,
    required TResult Function(BroadcastError_ConsensusError value)
        consensusError,
    required TResult Function(BroadcastError_Message value) message,
  }) {
    return networkError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BroadcastError_NetworkError value)? networkError,
    TResult? Function(BroadcastError_ConsensusError value)? consensusError,
    TResult? Function(BroadcastError_Message value)? message,
  }) {
    return networkError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BroadcastError_NetworkError value)? networkError,
    TResult Function(BroadcastError_ConsensusError value)? consensusError,
    TResult Function(BroadcastError_Message value)? message,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError(this);
    }
    return orElse();
  }
}

abstract class BroadcastError_NetworkError extends BroadcastError {
  const factory BroadcastError_NetworkError(final String field0) =
      _$BroadcastError_NetworkErrorImpl;
  const BroadcastError_NetworkError._() : super._();

  @override
  String get field0;

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BroadcastError_NetworkErrorImplCopyWith<_$BroadcastError_NetworkErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BroadcastError_ConsensusErrorImplCopyWith<$Res>
    implements $BroadcastErrorCopyWith<$Res> {
  factory _$$BroadcastError_ConsensusErrorImplCopyWith(
          _$BroadcastError_ConsensusErrorImpl value,
          $Res Function(_$BroadcastError_ConsensusErrorImpl) then) =
      __$$BroadcastError_ConsensusErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BroadcastError_ConsensusErrorImplCopyWithImpl<$Res>
    extends _$BroadcastErrorCopyWithImpl<$Res,
        _$BroadcastError_ConsensusErrorImpl>
    implements _$$BroadcastError_ConsensusErrorImplCopyWith<$Res> {
  __$$BroadcastError_ConsensusErrorImplCopyWithImpl(
      _$BroadcastError_ConsensusErrorImpl _value,
      $Res Function(_$BroadcastError_ConsensusErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BroadcastError_ConsensusErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BroadcastError_ConsensusErrorImpl
    extends BroadcastError_ConsensusError {
  const _$BroadcastError_ConsensusErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'BroadcastError.consensusError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BroadcastError_ConsensusErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BroadcastError_ConsensusErrorImplCopyWith<
          _$BroadcastError_ConsensusErrorImpl>
      get copyWith => __$$BroadcastError_ConsensusErrorImplCopyWithImpl<
          _$BroadcastError_ConsensusErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) networkError,
    required TResult Function(String field0) consensusError,
    required TResult Function(String field0) message,
  }) {
    return consensusError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? networkError,
    TResult? Function(String field0)? consensusError,
    TResult? Function(String field0)? message,
  }) {
    return consensusError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? networkError,
    TResult Function(String field0)? consensusError,
    TResult Function(String field0)? message,
    required TResult orElse(),
  }) {
    if (consensusError != null) {
      return consensusError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BroadcastError_NetworkError value) networkError,
    required TResult Function(BroadcastError_ConsensusError value)
        consensusError,
    required TResult Function(BroadcastError_Message value) message,
  }) {
    return consensusError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BroadcastError_NetworkError value)? networkError,
    TResult? Function(BroadcastError_ConsensusError value)? consensusError,
    TResult? Function(BroadcastError_Message value)? message,
  }) {
    return consensusError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BroadcastError_NetworkError value)? networkError,
    TResult Function(BroadcastError_ConsensusError value)? consensusError,
    TResult Function(BroadcastError_Message value)? message,
    required TResult orElse(),
  }) {
    if (consensusError != null) {
      return consensusError(this);
    }
    return orElse();
  }
}

abstract class BroadcastError_ConsensusError extends BroadcastError {
  const factory BroadcastError_ConsensusError(final String field0) =
      _$BroadcastError_ConsensusErrorImpl;
  const BroadcastError_ConsensusError._() : super._();

  @override
  String get field0;

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BroadcastError_ConsensusErrorImplCopyWith<
          _$BroadcastError_ConsensusErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BroadcastError_MessageImplCopyWith<$Res>
    implements $BroadcastErrorCopyWith<$Res> {
  factory _$$BroadcastError_MessageImplCopyWith(
          _$BroadcastError_MessageImpl value,
          $Res Function(_$BroadcastError_MessageImpl) then) =
      __$$BroadcastError_MessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BroadcastError_MessageImplCopyWithImpl<$Res>
    extends _$BroadcastErrorCopyWithImpl<$Res, _$BroadcastError_MessageImpl>
    implements _$$BroadcastError_MessageImplCopyWith<$Res> {
  __$$BroadcastError_MessageImplCopyWithImpl(
      _$BroadcastError_MessageImpl _value,
      $Res Function(_$BroadcastError_MessageImpl) _then)
      : super(_value, _then);

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BroadcastError_MessageImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BroadcastError_MessageImpl extends BroadcastError_Message {
  const _$BroadcastError_MessageImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'BroadcastError.message(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BroadcastError_MessageImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BroadcastError_MessageImplCopyWith<_$BroadcastError_MessageImpl>
      get copyWith => __$$BroadcastError_MessageImplCopyWithImpl<
          _$BroadcastError_MessageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) networkError,
    required TResult Function(String field0) consensusError,
    required TResult Function(String field0) message,
  }) {
    return message(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? networkError,
    TResult? Function(String field0)? consensusError,
    TResult? Function(String field0)? message,
  }) {
    return message?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? networkError,
    TResult Function(String field0)? consensusError,
    TResult Function(String field0)? message,
    required TResult orElse(),
  }) {
    if (message != null) {
      return message(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BroadcastError_NetworkError value) networkError,
    required TResult Function(BroadcastError_ConsensusError value)
        consensusError,
    required TResult Function(BroadcastError_Message value) message,
  }) {
    return message(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BroadcastError_NetworkError value)? networkError,
    TResult? Function(BroadcastError_ConsensusError value)? consensusError,
    TResult? Function(BroadcastError_Message value)? message,
  }) {
    return message?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BroadcastError_NetworkError value)? networkError,
    TResult Function(BroadcastError_ConsensusError value)? consensusError,
    TResult Function(BroadcastError_Message value)? message,
    required TResult orElse(),
  }) {
    if (message != null) {
      return message(this);
    }
    return orElse();
  }
}

abstract class BroadcastError_Message extends BroadcastError {
  const factory BroadcastError_Message(final String field0) =
      _$BroadcastError_MessageImpl;
  const BroadcastError_Message._() : super._();

  @override
  String get field0;

  /// Create a copy of BroadcastError
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BroadcastError_MessageImplCopyWith<_$BroadcastError_MessageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RBFBumpFeeError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RBFBumpFeeErrorCopyWith<$Res> {
  factory $RBFBumpFeeErrorCopyWith(
          RBFBumpFeeError value, $Res Function(RBFBumpFeeError) then) =
      _$RBFBumpFeeErrorCopyWithImpl<$Res, RBFBumpFeeError>;
}

/// @nodoc
class _$RBFBumpFeeErrorCopyWithImpl<$Res, $Val extends RBFBumpFeeError>
    implements $RBFBumpFeeErrorCopyWith<$Res> {
  _$RBFBumpFeeErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$RBFBumpFeeError_InsufficientFundsImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_InsufficientFundsImplCopyWith(
          _$RBFBumpFeeError_InsufficientFundsImpl value,
          $Res Function(_$RBFBumpFeeError_InsufficientFundsImpl) then) =
      __$$RBFBumpFeeError_InsufficientFundsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBFBumpFeeError_InsufficientFundsImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_InsufficientFundsImpl>
    implements _$$RBFBumpFeeError_InsufficientFundsImplCopyWith<$Res> {
  __$$RBFBumpFeeError_InsufficientFundsImplCopyWithImpl(
      _$RBFBumpFeeError_InsufficientFundsImpl _value,
      $Res Function(_$RBFBumpFeeError_InsufficientFundsImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBFBumpFeeError_InsufficientFundsImpl
    extends RBFBumpFeeError_InsufficientFunds {
  const _$RBFBumpFeeError_InsufficientFundsImpl() : super._();

  @override
  String toString() {
    return 'RBFBumpFeeError.insufficientFunds()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_InsufficientFundsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return insufficientFunds();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return insufficientFunds?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_InsufficientFunds extends RBFBumpFeeError {
  const factory RBFBumpFeeError_InsufficientFunds() =
      _$RBFBumpFeeError_InsufficientFundsImpl;
  const RBFBumpFeeError_InsufficientFunds._() : super._();
}

/// @nodoc
abstract class _$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWith(
          _$RBFBumpFeeError_ComposeBumpTxErrorImpl value,
          $Res Function(_$RBFBumpFeeError_ComposeBumpTxErrorImpl) then) =
      __$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_ComposeBumpTxErrorImpl>
    implements _$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWith<$Res> {
  __$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWithImpl(
      _$RBFBumpFeeError_ComposeBumpTxErrorImpl _value,
      $Res Function(_$RBFBumpFeeError_ComposeBumpTxErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RBFBumpFeeError_ComposeBumpTxErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RBFBumpFeeError_ComposeBumpTxErrorImpl
    extends RBFBumpFeeError_ComposeBumpTxError {
  const _$RBFBumpFeeError_ComposeBumpTxErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'RBFBumpFeeError.composeBumpTxError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_ComposeBumpTxErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWith<
          _$RBFBumpFeeError_ComposeBumpTxErrorImpl>
      get copyWith => __$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWithImpl<
          _$RBFBumpFeeError_ComposeBumpTxErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return composeBumpTxError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return composeBumpTxError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (composeBumpTxError != null) {
      return composeBumpTxError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return composeBumpTxError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return composeBumpTxError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (composeBumpTxError != null) {
      return composeBumpTxError(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_ComposeBumpTxError extends RBFBumpFeeError {
  const factory RBFBumpFeeError_ComposeBumpTxError(final String field0) =
      _$RBFBumpFeeError_ComposeBumpTxErrorImpl;
  const RBFBumpFeeError_ComposeBumpTxError._() : super._();

  String get field0;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RBFBumpFeeError_ComposeBumpTxErrorImplCopyWith<
          _$RBFBumpFeeError_ComposeBumpTxErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RBFBumpFeeError_ComposeTxErrorImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_ComposeTxErrorImplCopyWith(
          _$RBFBumpFeeError_ComposeTxErrorImpl value,
          $Res Function(_$RBFBumpFeeError_ComposeTxErrorImpl) then) =
      __$$RBFBumpFeeError_ComposeTxErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$RBFBumpFeeError_ComposeTxErrorImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_ComposeTxErrorImpl>
    implements _$$RBFBumpFeeError_ComposeTxErrorImplCopyWith<$Res> {
  __$$RBFBumpFeeError_ComposeTxErrorImplCopyWithImpl(
      _$RBFBumpFeeError_ComposeTxErrorImpl _value,
      $Res Function(_$RBFBumpFeeError_ComposeTxErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RBFBumpFeeError_ComposeTxErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RBFBumpFeeError_ComposeTxErrorImpl
    extends RBFBumpFeeError_ComposeTxError {
  const _$RBFBumpFeeError_ComposeTxErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'RBFBumpFeeError.composeTxError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_ComposeTxErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RBFBumpFeeError_ComposeTxErrorImplCopyWith<
          _$RBFBumpFeeError_ComposeTxErrorImpl>
      get copyWith => __$$RBFBumpFeeError_ComposeTxErrorImplCopyWithImpl<
          _$RBFBumpFeeError_ComposeTxErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return composeTxError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return composeTxError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (composeTxError != null) {
      return composeTxError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return composeTxError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return composeTxError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (composeTxError != null) {
      return composeTxError(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_ComposeTxError extends RBFBumpFeeError {
  const factory RBFBumpFeeError_ComposeTxError(final String field0) =
      _$RBFBumpFeeError_ComposeTxErrorImpl;
  const RBFBumpFeeError_ComposeTxError._() : super._();

  String get field0;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RBFBumpFeeError_ComposeTxErrorImplCopyWith<
          _$RBFBumpFeeError_ComposeTxErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RBFBumpFeeError_ChangeOutputLockedImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_ChangeOutputLockedImplCopyWith(
          _$RBFBumpFeeError_ChangeOutputLockedImpl value,
          $Res Function(_$RBFBumpFeeError_ChangeOutputLockedImpl) then) =
      __$$RBFBumpFeeError_ChangeOutputLockedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBFBumpFeeError_ChangeOutputLockedImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_ChangeOutputLockedImpl>
    implements _$$RBFBumpFeeError_ChangeOutputLockedImplCopyWith<$Res> {
  __$$RBFBumpFeeError_ChangeOutputLockedImplCopyWithImpl(
      _$RBFBumpFeeError_ChangeOutputLockedImpl _value,
      $Res Function(_$RBFBumpFeeError_ChangeOutputLockedImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBFBumpFeeError_ChangeOutputLockedImpl
    extends RBFBumpFeeError_ChangeOutputLocked {
  const _$RBFBumpFeeError_ChangeOutputLockedImpl() : super._();

  @override
  String toString() {
    return 'RBFBumpFeeError.changeOutputLocked()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_ChangeOutputLockedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return changeOutputLocked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return changeOutputLocked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (changeOutputLocked != null) {
      return changeOutputLocked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return changeOutputLocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return changeOutputLocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (changeOutputLocked != null) {
      return changeOutputLocked(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_ChangeOutputLocked extends RBFBumpFeeError {
  const factory RBFBumpFeeError_ChangeOutputLocked() =
      _$RBFBumpFeeError_ChangeOutputLockedImpl;
  const RBFBumpFeeError_ChangeOutputLocked._() : super._();
}

/// @nodoc
abstract class _$$RBFBumpFeeError_UnknownUtxoImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_UnknownUtxoImplCopyWith(
          _$RBFBumpFeeError_UnknownUtxoImpl value,
          $Res Function(_$RBFBumpFeeError_UnknownUtxoImpl) then) =
      __$$RBFBumpFeeError_UnknownUtxoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$RBFBumpFeeError_UnknownUtxoImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_UnknownUtxoImpl>
    implements _$$RBFBumpFeeError_UnknownUtxoImplCopyWith<$Res> {
  __$$RBFBumpFeeError_UnknownUtxoImplCopyWithImpl(
      _$RBFBumpFeeError_UnknownUtxoImpl _value,
      $Res Function(_$RBFBumpFeeError_UnknownUtxoImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RBFBumpFeeError_UnknownUtxoImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RBFBumpFeeError_UnknownUtxoImpl extends RBFBumpFeeError_UnknownUtxo {
  const _$RBFBumpFeeError_UnknownUtxoImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'RBFBumpFeeError.unknownUtxo(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_UnknownUtxoImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RBFBumpFeeError_UnknownUtxoImplCopyWith<_$RBFBumpFeeError_UnknownUtxoImpl>
      get copyWith => __$$RBFBumpFeeError_UnknownUtxoImplCopyWithImpl<
          _$RBFBumpFeeError_UnknownUtxoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return unknownUtxo(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return unknownUtxo?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (unknownUtxo != null) {
      return unknownUtxo(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return unknownUtxo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return unknownUtxo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (unknownUtxo != null) {
      return unknownUtxo(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_UnknownUtxo extends RBFBumpFeeError {
  const factory RBFBumpFeeError_UnknownUtxo(final String field0) =
      _$RBFBumpFeeError_UnknownUtxoImpl;
  const RBFBumpFeeError_UnknownUtxo._() : super._();

  String get field0;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RBFBumpFeeError_UnknownUtxoImplCopyWith<_$RBFBumpFeeError_UnknownUtxoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RBFBumpFeeError_TransactionNotFoundImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_TransactionNotFoundImplCopyWith(
          _$RBFBumpFeeError_TransactionNotFoundImpl value,
          $Res Function(_$RBFBumpFeeError_TransactionNotFoundImpl) then) =
      __$$RBFBumpFeeError_TransactionNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBFBumpFeeError_TransactionNotFoundImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_TransactionNotFoundImpl>
    implements _$$RBFBumpFeeError_TransactionNotFoundImplCopyWith<$Res> {
  __$$RBFBumpFeeError_TransactionNotFoundImplCopyWithImpl(
      _$RBFBumpFeeError_TransactionNotFoundImpl _value,
      $Res Function(_$RBFBumpFeeError_TransactionNotFoundImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBFBumpFeeError_TransactionNotFoundImpl
    extends RBFBumpFeeError_TransactionNotFound {
  const _$RBFBumpFeeError_TransactionNotFoundImpl() : super._();

  @override
  String toString() {
    return 'RBFBumpFeeError.transactionNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_TransactionNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return transactionNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return transactionNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (transactionNotFound != null) {
      return transactionNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return transactionNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return transactionNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (transactionNotFound != null) {
      return transactionNotFound(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_TransactionNotFound extends RBFBumpFeeError {
  const factory RBFBumpFeeError_TransactionNotFound() =
      _$RBFBumpFeeError_TransactionNotFoundImpl;
  const RBFBumpFeeError_TransactionNotFound._() : super._();
}

/// @nodoc
abstract class _$$RBFBumpFeeError_TransactionConfirmedImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_TransactionConfirmedImplCopyWith(
          _$RBFBumpFeeError_TransactionConfirmedImpl value,
          $Res Function(_$RBFBumpFeeError_TransactionConfirmedImpl) then) =
      __$$RBFBumpFeeError_TransactionConfirmedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$RBFBumpFeeError_TransactionConfirmedImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_TransactionConfirmedImpl>
    implements _$$RBFBumpFeeError_TransactionConfirmedImplCopyWith<$Res> {
  __$$RBFBumpFeeError_TransactionConfirmedImplCopyWithImpl(
      _$RBFBumpFeeError_TransactionConfirmedImpl _value,
      $Res Function(_$RBFBumpFeeError_TransactionConfirmedImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RBFBumpFeeError_TransactionConfirmedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RBFBumpFeeError_TransactionConfirmedImpl
    extends RBFBumpFeeError_TransactionConfirmed {
  const _$RBFBumpFeeError_TransactionConfirmedImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'RBFBumpFeeError.transactionConfirmed(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_TransactionConfirmedImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RBFBumpFeeError_TransactionConfirmedImplCopyWith<
          _$RBFBumpFeeError_TransactionConfirmedImpl>
      get copyWith => __$$RBFBumpFeeError_TransactionConfirmedImplCopyWithImpl<
          _$RBFBumpFeeError_TransactionConfirmedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return transactionConfirmed(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return transactionConfirmed?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (transactionConfirmed != null) {
      return transactionConfirmed(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return transactionConfirmed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return transactionConfirmed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (transactionConfirmed != null) {
      return transactionConfirmed(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_TransactionConfirmed extends RBFBumpFeeError {
  const factory RBFBumpFeeError_TransactionConfirmed(final String field0) =
      _$RBFBumpFeeError_TransactionConfirmedImpl;
  const RBFBumpFeeError_TransactionConfirmed._() : super._();

  String get field0;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RBFBumpFeeError_TransactionConfirmedImplCopyWith<
          _$RBFBumpFeeError_TransactionConfirmedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWith(
          _$RBFBumpFeeError_IrreplaceableTransactionImpl value,
          $Res Function(_$RBFBumpFeeError_IrreplaceableTransactionImpl) then) =
      __$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_IrreplaceableTransactionImpl>
    implements _$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWith<$Res> {
  __$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWithImpl(
      _$RBFBumpFeeError_IrreplaceableTransactionImpl _value,
      $Res Function(_$RBFBumpFeeError_IrreplaceableTransactionImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RBFBumpFeeError_IrreplaceableTransactionImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RBFBumpFeeError_IrreplaceableTransactionImpl
    extends RBFBumpFeeError_IrreplaceableTransaction {
  const _$RBFBumpFeeError_IrreplaceableTransactionImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'RBFBumpFeeError.irreplaceableTransaction(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_IrreplaceableTransactionImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWith<
          _$RBFBumpFeeError_IrreplaceableTransactionImpl>
      get copyWith =>
          __$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWithImpl<
              _$RBFBumpFeeError_IrreplaceableTransactionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return irreplaceableTransaction(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return irreplaceableTransaction?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (irreplaceableTransaction != null) {
      return irreplaceableTransaction(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return irreplaceableTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return irreplaceableTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (irreplaceableTransaction != null) {
      return irreplaceableTransaction(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_IrreplaceableTransaction
    extends RBFBumpFeeError {
  const factory RBFBumpFeeError_IrreplaceableTransaction(final String field0) =
      _$RBFBumpFeeError_IrreplaceableTransactionImpl;
  const RBFBumpFeeError_IrreplaceableTransaction._() : super._();

  String get field0;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RBFBumpFeeError_IrreplaceableTransactionImplCopyWith<
          _$RBFBumpFeeError_IrreplaceableTransactionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RBFBumpFeeError_FeeRateUnavailableImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_FeeRateUnavailableImplCopyWith(
          _$RBFBumpFeeError_FeeRateUnavailableImpl value,
          $Res Function(_$RBFBumpFeeError_FeeRateUnavailableImpl) then) =
      __$$RBFBumpFeeError_FeeRateUnavailableImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBFBumpFeeError_FeeRateUnavailableImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_FeeRateUnavailableImpl>
    implements _$$RBFBumpFeeError_FeeRateUnavailableImplCopyWith<$Res> {
  __$$RBFBumpFeeError_FeeRateUnavailableImplCopyWithImpl(
      _$RBFBumpFeeError_FeeRateUnavailableImpl _value,
      $Res Function(_$RBFBumpFeeError_FeeRateUnavailableImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBFBumpFeeError_FeeRateUnavailableImpl
    extends RBFBumpFeeError_FeeRateUnavailable {
  const _$RBFBumpFeeError_FeeRateUnavailableImpl() : super._();

  @override
  String toString() {
    return 'RBFBumpFeeError.feeRateUnavailable()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_FeeRateUnavailableImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return feeRateUnavailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return feeRateUnavailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (feeRateUnavailable != null) {
      return feeRateUnavailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return feeRateUnavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return feeRateUnavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (feeRateUnavailable != null) {
      return feeRateUnavailable(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_FeeRateUnavailable extends RBFBumpFeeError {
  const factory RBFBumpFeeError_FeeRateUnavailable() =
      _$RBFBumpFeeError_FeeRateUnavailableImpl;
  const RBFBumpFeeError_FeeRateUnavailable._() : super._();
}

/// @nodoc
abstract class _$$RBFBumpFeeError_UnableToAccessWalletImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_UnableToAccessWalletImplCopyWith(
          _$RBFBumpFeeError_UnableToAccessWalletImpl value,
          $Res Function(_$RBFBumpFeeError_UnableToAccessWalletImpl) then) =
      __$$RBFBumpFeeError_UnableToAccessWalletImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBFBumpFeeError_UnableToAccessWalletImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_UnableToAccessWalletImpl>
    implements _$$RBFBumpFeeError_UnableToAccessWalletImplCopyWith<$Res> {
  __$$RBFBumpFeeError_UnableToAccessWalletImplCopyWithImpl(
      _$RBFBumpFeeError_UnableToAccessWalletImpl _value,
      $Res Function(_$RBFBumpFeeError_UnableToAccessWalletImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBFBumpFeeError_UnableToAccessWalletImpl
    extends RBFBumpFeeError_UnableToAccessWallet {
  const _$RBFBumpFeeError_UnableToAccessWalletImpl() : super._();

  @override
  String toString() {
    return 'RBFBumpFeeError.unableToAccessWallet()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_UnableToAccessWalletImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return unableToAccessWallet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return unableToAccessWallet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (unableToAccessWallet != null) {
      return unableToAccessWallet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return unableToAccessWallet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return unableToAccessWallet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (unableToAccessWallet != null) {
      return unableToAccessWallet(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_UnableToAccessWallet extends RBFBumpFeeError {
  const factory RBFBumpFeeError_UnableToAccessWallet() =
      _$RBFBumpFeeError_UnableToAccessWalletImpl;
  const RBFBumpFeeError_UnableToAccessWallet._() : super._();
}

/// @nodoc
abstract class _$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWith(
          _$RBFBumpFeeError_UnableToAddForeignUtxoImpl value,
          $Res Function(_$RBFBumpFeeError_UnableToAddForeignUtxoImpl) then) =
      __$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_UnableToAddForeignUtxoImpl>
    implements _$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWith<$Res> {
  __$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWithImpl(
      _$RBFBumpFeeError_UnableToAddForeignUtxoImpl _value,
      $Res Function(_$RBFBumpFeeError_UnableToAddForeignUtxoImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RBFBumpFeeError_UnableToAddForeignUtxoImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$RBFBumpFeeError_UnableToAddForeignUtxoImpl
    extends RBFBumpFeeError_UnableToAddForeignUtxo {
  const _$RBFBumpFeeError_UnableToAddForeignUtxoImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'RBFBumpFeeError.unableToAddForeignUtxo(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_UnableToAddForeignUtxoImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWith<
          _$RBFBumpFeeError_UnableToAddForeignUtxoImpl>
      get copyWith =>
          __$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWithImpl<
              _$RBFBumpFeeError_UnableToAddForeignUtxoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return unableToAddForeignUtxo(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return unableToAddForeignUtxo?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (unableToAddForeignUtxo != null) {
      return unableToAddForeignUtxo(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return unableToAddForeignUtxo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return unableToAddForeignUtxo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (unableToAddForeignUtxo != null) {
      return unableToAddForeignUtxo(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_UnableToAddForeignUtxo extends RBFBumpFeeError {
  const factory RBFBumpFeeError_UnableToAddForeignUtxo(final String field0) =
      _$RBFBumpFeeError_UnableToAddForeignUtxoImpl;
  const RBFBumpFeeError_UnableToAddForeignUtxo._() : super._();

  String get field0;

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RBFBumpFeeError_UnableToAddForeignUtxoImplCopyWith<
          _$RBFBumpFeeError_UnableToAddForeignUtxoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RBFBumpFeeError_WalletNotAvailableImplCopyWith<$Res> {
  factory _$$RBFBumpFeeError_WalletNotAvailableImplCopyWith(
          _$RBFBumpFeeError_WalletNotAvailableImpl value,
          $Res Function(_$RBFBumpFeeError_WalletNotAvailableImpl) then) =
      __$$RBFBumpFeeError_WalletNotAvailableImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBFBumpFeeError_WalletNotAvailableImplCopyWithImpl<$Res>
    extends _$RBFBumpFeeErrorCopyWithImpl<$Res,
        _$RBFBumpFeeError_WalletNotAvailableImpl>
    implements _$$RBFBumpFeeError_WalletNotAvailableImplCopyWith<$Res> {
  __$$RBFBumpFeeError_WalletNotAvailableImplCopyWithImpl(
      _$RBFBumpFeeError_WalletNotAvailableImpl _value,
      $Res Function(_$RBFBumpFeeError_WalletNotAvailableImpl) _then)
      : super(_value, _then);

  /// Create a copy of RBFBumpFeeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBFBumpFeeError_WalletNotAvailableImpl
    extends RBFBumpFeeError_WalletNotAvailable {
  const _$RBFBumpFeeError_WalletNotAvailableImpl() : super._();

  @override
  String toString() {
    return 'RBFBumpFeeError.walletNotAvailable()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RBFBumpFeeError_WalletNotAvailableImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() insufficientFunds,
    required TResult Function(String field0) composeBumpTxError,
    required TResult Function(String field0) composeTxError,
    required TResult Function() changeOutputLocked,
    required TResult Function(String field0) unknownUtxo,
    required TResult Function() transactionNotFound,
    required TResult Function(String field0) transactionConfirmed,
    required TResult Function(String field0) irreplaceableTransaction,
    required TResult Function() feeRateUnavailable,
    required TResult Function() unableToAccessWallet,
    required TResult Function(String field0) unableToAddForeignUtxo,
    required TResult Function() walletNotAvailable,
  }) {
    return walletNotAvailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? insufficientFunds,
    TResult? Function(String field0)? composeBumpTxError,
    TResult? Function(String field0)? composeTxError,
    TResult? Function()? changeOutputLocked,
    TResult? Function(String field0)? unknownUtxo,
    TResult? Function()? transactionNotFound,
    TResult? Function(String field0)? transactionConfirmed,
    TResult? Function(String field0)? irreplaceableTransaction,
    TResult? Function()? feeRateUnavailable,
    TResult? Function()? unableToAccessWallet,
    TResult? Function(String field0)? unableToAddForeignUtxo,
    TResult? Function()? walletNotAvailable,
  }) {
    return walletNotAvailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? insufficientFunds,
    TResult Function(String field0)? composeBumpTxError,
    TResult Function(String field0)? composeTxError,
    TResult Function()? changeOutputLocked,
    TResult Function(String field0)? unknownUtxo,
    TResult Function()? transactionNotFound,
    TResult Function(String field0)? transactionConfirmed,
    TResult Function(String field0)? irreplaceableTransaction,
    TResult Function()? feeRateUnavailable,
    TResult Function()? unableToAccessWallet,
    TResult Function(String field0)? unableToAddForeignUtxo,
    TResult Function()? walletNotAvailable,
    required TResult orElse(),
  }) {
    if (walletNotAvailable != null) {
      return walletNotAvailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RBFBumpFeeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(RBFBumpFeeError_ComposeBumpTxError value)
        composeBumpTxError,
    required TResult Function(RBFBumpFeeError_ComposeTxError value)
        composeTxError,
    required TResult Function(RBFBumpFeeError_ChangeOutputLocked value)
        changeOutputLocked,
    required TResult Function(RBFBumpFeeError_UnknownUtxo value) unknownUtxo,
    required TResult Function(RBFBumpFeeError_TransactionNotFound value)
        transactionNotFound,
    required TResult Function(RBFBumpFeeError_TransactionConfirmed value)
        transactionConfirmed,
    required TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)
        irreplaceableTransaction,
    required TResult Function(RBFBumpFeeError_FeeRateUnavailable value)
        feeRateUnavailable,
    required TResult Function(RBFBumpFeeError_UnableToAccessWallet value)
        unableToAccessWallet,
    required TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)
        unableToAddForeignUtxo,
    required TResult Function(RBFBumpFeeError_WalletNotAvailable value)
        walletNotAvailable,
  }) {
    return walletNotAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult? Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult? Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult? Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult? Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult? Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult? Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult? Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult? Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult? Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult? Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
  }) {
    return walletNotAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RBFBumpFeeError_InsufficientFunds value)?
        insufficientFunds,
    TResult Function(RBFBumpFeeError_ComposeBumpTxError value)?
        composeBumpTxError,
    TResult Function(RBFBumpFeeError_ComposeTxError value)? composeTxError,
    TResult Function(RBFBumpFeeError_ChangeOutputLocked value)?
        changeOutputLocked,
    TResult Function(RBFBumpFeeError_UnknownUtxo value)? unknownUtxo,
    TResult Function(RBFBumpFeeError_TransactionNotFound value)?
        transactionNotFound,
    TResult Function(RBFBumpFeeError_TransactionConfirmed value)?
        transactionConfirmed,
    TResult Function(RBFBumpFeeError_IrreplaceableTransaction value)?
        irreplaceableTransaction,
    TResult Function(RBFBumpFeeError_FeeRateUnavailable value)?
        feeRateUnavailable,
    TResult Function(RBFBumpFeeError_UnableToAccessWallet value)?
        unableToAccessWallet,
    TResult Function(RBFBumpFeeError_UnableToAddForeignUtxo value)?
        unableToAddForeignUtxo,
    TResult Function(RBFBumpFeeError_WalletNotAvailable value)?
        walletNotAvailable,
    required TResult orElse(),
  }) {
    if (walletNotAvailable != null) {
      return walletNotAvailable(this);
    }
    return orElse();
  }
}

abstract class RBFBumpFeeError_WalletNotAvailable extends RBFBumpFeeError {
  const factory RBFBumpFeeError_WalletNotAvailable() =
      _$RBFBumpFeeError_WalletNotAvailableImpl;
  const RBFBumpFeeError_WalletNotAvailable._() : super._();
}

/// @nodoc
mixin _$TxComposeError {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) coinSelectionError,
    required TResult Function(String field0) error,
    required TResult Function(String field0) insufficientFunds,
    required TResult Function(BigInt field0) insufficientFees,
    required TResult Function(BigInt field0) insufficientFeeRate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? coinSelectionError,
    TResult? Function(String field0)? error,
    TResult? Function(String field0)? insufficientFunds,
    TResult? Function(BigInt field0)? insufficientFees,
    TResult? Function(BigInt field0)? insufficientFeeRate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? coinSelectionError,
    TResult Function(String field0)? error,
    TResult Function(String field0)? insufficientFunds,
    TResult Function(BigInt field0)? insufficientFees,
    TResult Function(BigInt field0)? insufficientFeeRate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxComposeError_CoinSelectionError value)
        coinSelectionError,
    required TResult Function(TxComposeError_Error value) error,
    required TResult Function(TxComposeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(TxComposeError_InsufficientFees value)
        insufficientFees,
    required TResult Function(TxComposeError_InsufficientFeeRate value)
        insufficientFeeRate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult? Function(TxComposeError_Error value)? error,
    TResult? Function(TxComposeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult? Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult Function(TxComposeError_Error value)? error,
    TResult Function(TxComposeError_InsufficientFunds value)? insufficientFunds,
    TResult Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TxComposeErrorCopyWith<$Res> {
  factory $TxComposeErrorCopyWith(
          TxComposeError value, $Res Function(TxComposeError) then) =
      _$TxComposeErrorCopyWithImpl<$Res, TxComposeError>;
}

/// @nodoc
class _$TxComposeErrorCopyWithImpl<$Res, $Val extends TxComposeError>
    implements $TxComposeErrorCopyWith<$Res> {
  _$TxComposeErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$TxComposeError_CoinSelectionErrorImplCopyWith<$Res> {
  factory _$$TxComposeError_CoinSelectionErrorImplCopyWith(
          _$TxComposeError_CoinSelectionErrorImpl value,
          $Res Function(_$TxComposeError_CoinSelectionErrorImpl) then) =
      __$$TxComposeError_CoinSelectionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$TxComposeError_CoinSelectionErrorImplCopyWithImpl<$Res>
    extends _$TxComposeErrorCopyWithImpl<$Res,
        _$TxComposeError_CoinSelectionErrorImpl>
    implements _$$TxComposeError_CoinSelectionErrorImplCopyWith<$Res> {
  __$$TxComposeError_CoinSelectionErrorImplCopyWithImpl(
      _$TxComposeError_CoinSelectionErrorImpl _value,
      $Res Function(_$TxComposeError_CoinSelectionErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$TxComposeError_CoinSelectionErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TxComposeError_CoinSelectionErrorImpl
    extends TxComposeError_CoinSelectionError {
  const _$TxComposeError_CoinSelectionErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'TxComposeError.coinSelectionError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxComposeError_CoinSelectionErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TxComposeError_CoinSelectionErrorImplCopyWith<
          _$TxComposeError_CoinSelectionErrorImpl>
      get copyWith => __$$TxComposeError_CoinSelectionErrorImplCopyWithImpl<
          _$TxComposeError_CoinSelectionErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) coinSelectionError,
    required TResult Function(String field0) error,
    required TResult Function(String field0) insufficientFunds,
    required TResult Function(BigInt field0) insufficientFees,
    required TResult Function(BigInt field0) insufficientFeeRate,
  }) {
    return coinSelectionError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? coinSelectionError,
    TResult? Function(String field0)? error,
    TResult? Function(String field0)? insufficientFunds,
    TResult? Function(BigInt field0)? insufficientFees,
    TResult? Function(BigInt field0)? insufficientFeeRate,
  }) {
    return coinSelectionError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? coinSelectionError,
    TResult Function(String field0)? error,
    TResult Function(String field0)? insufficientFunds,
    TResult Function(BigInt field0)? insufficientFees,
    TResult Function(BigInt field0)? insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (coinSelectionError != null) {
      return coinSelectionError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxComposeError_CoinSelectionError value)
        coinSelectionError,
    required TResult Function(TxComposeError_Error value) error,
    required TResult Function(TxComposeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(TxComposeError_InsufficientFees value)
        insufficientFees,
    required TResult Function(TxComposeError_InsufficientFeeRate value)
        insufficientFeeRate,
  }) {
    return coinSelectionError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult? Function(TxComposeError_Error value)? error,
    TResult? Function(TxComposeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult? Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
  }) {
    return coinSelectionError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult Function(TxComposeError_Error value)? error,
    TResult Function(TxComposeError_InsufficientFunds value)? insufficientFunds,
    TResult Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (coinSelectionError != null) {
      return coinSelectionError(this);
    }
    return orElse();
  }
}

abstract class TxComposeError_CoinSelectionError extends TxComposeError {
  const factory TxComposeError_CoinSelectionError(final String field0) =
      _$TxComposeError_CoinSelectionErrorImpl;
  const TxComposeError_CoinSelectionError._() : super._();

  @override
  String get field0;

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TxComposeError_CoinSelectionErrorImplCopyWith<
          _$TxComposeError_CoinSelectionErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TxComposeError_ErrorImplCopyWith<$Res> {
  factory _$$TxComposeError_ErrorImplCopyWith(_$TxComposeError_ErrorImpl value,
          $Res Function(_$TxComposeError_ErrorImpl) then) =
      __$$TxComposeError_ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$TxComposeError_ErrorImplCopyWithImpl<$Res>
    extends _$TxComposeErrorCopyWithImpl<$Res, _$TxComposeError_ErrorImpl>
    implements _$$TxComposeError_ErrorImplCopyWith<$Res> {
  __$$TxComposeError_ErrorImplCopyWithImpl(_$TxComposeError_ErrorImpl _value,
      $Res Function(_$TxComposeError_ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$TxComposeError_ErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TxComposeError_ErrorImpl extends TxComposeError_Error {
  const _$TxComposeError_ErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'TxComposeError.error(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxComposeError_ErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TxComposeError_ErrorImplCopyWith<_$TxComposeError_ErrorImpl>
      get copyWith =>
          __$$TxComposeError_ErrorImplCopyWithImpl<_$TxComposeError_ErrorImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) coinSelectionError,
    required TResult Function(String field0) error,
    required TResult Function(String field0) insufficientFunds,
    required TResult Function(BigInt field0) insufficientFees,
    required TResult Function(BigInt field0) insufficientFeeRate,
  }) {
    return error(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? coinSelectionError,
    TResult? Function(String field0)? error,
    TResult? Function(String field0)? insufficientFunds,
    TResult? Function(BigInt field0)? insufficientFees,
    TResult? Function(BigInt field0)? insufficientFeeRate,
  }) {
    return error?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? coinSelectionError,
    TResult Function(String field0)? error,
    TResult Function(String field0)? insufficientFunds,
    TResult Function(BigInt field0)? insufficientFees,
    TResult Function(BigInt field0)? insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxComposeError_CoinSelectionError value)
        coinSelectionError,
    required TResult Function(TxComposeError_Error value) error,
    required TResult Function(TxComposeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(TxComposeError_InsufficientFees value)
        insufficientFees,
    required TResult Function(TxComposeError_InsufficientFeeRate value)
        insufficientFeeRate,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult? Function(TxComposeError_Error value)? error,
    TResult? Function(TxComposeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult? Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult Function(TxComposeError_Error value)? error,
    TResult Function(TxComposeError_InsufficientFunds value)? insufficientFunds,
    TResult Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class TxComposeError_Error extends TxComposeError {
  const factory TxComposeError_Error(final String field0) =
      _$TxComposeError_ErrorImpl;
  const TxComposeError_Error._() : super._();

  @override
  String get field0;

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TxComposeError_ErrorImplCopyWith<_$TxComposeError_ErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TxComposeError_InsufficientFundsImplCopyWith<$Res> {
  factory _$$TxComposeError_InsufficientFundsImplCopyWith(
          _$TxComposeError_InsufficientFundsImpl value,
          $Res Function(_$TxComposeError_InsufficientFundsImpl) then) =
      __$$TxComposeError_InsufficientFundsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$TxComposeError_InsufficientFundsImplCopyWithImpl<$Res>
    extends _$TxComposeErrorCopyWithImpl<$Res,
        _$TxComposeError_InsufficientFundsImpl>
    implements _$$TxComposeError_InsufficientFundsImplCopyWith<$Res> {
  __$$TxComposeError_InsufficientFundsImplCopyWithImpl(
      _$TxComposeError_InsufficientFundsImpl _value,
      $Res Function(_$TxComposeError_InsufficientFundsImpl) _then)
      : super(_value, _then);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$TxComposeError_InsufficientFundsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TxComposeError_InsufficientFundsImpl
    extends TxComposeError_InsufficientFunds {
  const _$TxComposeError_InsufficientFundsImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'TxComposeError.insufficientFunds(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxComposeError_InsufficientFundsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TxComposeError_InsufficientFundsImplCopyWith<
          _$TxComposeError_InsufficientFundsImpl>
      get copyWith => __$$TxComposeError_InsufficientFundsImplCopyWithImpl<
          _$TxComposeError_InsufficientFundsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) coinSelectionError,
    required TResult Function(String field0) error,
    required TResult Function(String field0) insufficientFunds,
    required TResult Function(BigInt field0) insufficientFees,
    required TResult Function(BigInt field0) insufficientFeeRate,
  }) {
    return insufficientFunds(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? coinSelectionError,
    TResult? Function(String field0)? error,
    TResult? Function(String field0)? insufficientFunds,
    TResult? Function(BigInt field0)? insufficientFees,
    TResult? Function(BigInt field0)? insufficientFeeRate,
  }) {
    return insufficientFunds?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? coinSelectionError,
    TResult Function(String field0)? error,
    TResult Function(String field0)? insufficientFunds,
    TResult Function(BigInt field0)? insufficientFees,
    TResult Function(BigInt field0)? insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxComposeError_CoinSelectionError value)
        coinSelectionError,
    required TResult Function(TxComposeError_Error value) error,
    required TResult Function(TxComposeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(TxComposeError_InsufficientFees value)
        insufficientFees,
    required TResult Function(TxComposeError_InsufficientFeeRate value)
        insufficientFeeRate,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult? Function(TxComposeError_Error value)? error,
    TResult? Function(TxComposeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult? Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult Function(TxComposeError_Error value)? error,
    TResult Function(TxComposeError_InsufficientFunds value)? insufficientFunds,
    TResult Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class TxComposeError_InsufficientFunds extends TxComposeError {
  const factory TxComposeError_InsufficientFunds(final String field0) =
      _$TxComposeError_InsufficientFundsImpl;
  const TxComposeError_InsufficientFunds._() : super._();

  @override
  String get field0;

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TxComposeError_InsufficientFundsImplCopyWith<
          _$TxComposeError_InsufficientFundsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TxComposeError_InsufficientFeesImplCopyWith<$Res> {
  factory _$$TxComposeError_InsufficientFeesImplCopyWith(
          _$TxComposeError_InsufficientFeesImpl value,
          $Res Function(_$TxComposeError_InsufficientFeesImpl) then) =
      __$$TxComposeError_InsufficientFeesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$TxComposeError_InsufficientFeesImplCopyWithImpl<$Res>
    extends _$TxComposeErrorCopyWithImpl<$Res,
        _$TxComposeError_InsufficientFeesImpl>
    implements _$$TxComposeError_InsufficientFeesImplCopyWith<$Res> {
  __$$TxComposeError_InsufficientFeesImplCopyWithImpl(
      _$TxComposeError_InsufficientFeesImpl _value,
      $Res Function(_$TxComposeError_InsufficientFeesImpl) _then)
      : super(_value, _then);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$TxComposeError_InsufficientFeesImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$TxComposeError_InsufficientFeesImpl
    extends TxComposeError_InsufficientFees {
  const _$TxComposeError_InsufficientFeesImpl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'TxComposeError.insufficientFees(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxComposeError_InsufficientFeesImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TxComposeError_InsufficientFeesImplCopyWith<
          _$TxComposeError_InsufficientFeesImpl>
      get copyWith => __$$TxComposeError_InsufficientFeesImplCopyWithImpl<
          _$TxComposeError_InsufficientFeesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) coinSelectionError,
    required TResult Function(String field0) error,
    required TResult Function(String field0) insufficientFunds,
    required TResult Function(BigInt field0) insufficientFees,
    required TResult Function(BigInt field0) insufficientFeeRate,
  }) {
    return insufficientFees(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? coinSelectionError,
    TResult? Function(String field0)? error,
    TResult? Function(String field0)? insufficientFunds,
    TResult? Function(BigInt field0)? insufficientFees,
    TResult? Function(BigInt field0)? insufficientFeeRate,
  }) {
    return insufficientFees?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? coinSelectionError,
    TResult Function(String field0)? error,
    TResult Function(String field0)? insufficientFunds,
    TResult Function(BigInt field0)? insufficientFees,
    TResult Function(BigInt field0)? insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (insufficientFees != null) {
      return insufficientFees(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxComposeError_CoinSelectionError value)
        coinSelectionError,
    required TResult Function(TxComposeError_Error value) error,
    required TResult Function(TxComposeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(TxComposeError_InsufficientFees value)
        insufficientFees,
    required TResult Function(TxComposeError_InsufficientFeeRate value)
        insufficientFeeRate,
  }) {
    return insufficientFees(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult? Function(TxComposeError_Error value)? error,
    TResult? Function(TxComposeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult? Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
  }) {
    return insufficientFees?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult Function(TxComposeError_Error value)? error,
    TResult Function(TxComposeError_InsufficientFunds value)? insufficientFunds,
    TResult Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (insufficientFees != null) {
      return insufficientFees(this);
    }
    return orElse();
  }
}

abstract class TxComposeError_InsufficientFees extends TxComposeError {
  const factory TxComposeError_InsufficientFees(final BigInt field0) =
      _$TxComposeError_InsufficientFeesImpl;
  const TxComposeError_InsufficientFees._() : super._();

  @override
  BigInt get field0;

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TxComposeError_InsufficientFeesImplCopyWith<
          _$TxComposeError_InsufficientFeesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TxComposeError_InsufficientFeeRateImplCopyWith<$Res> {
  factory _$$TxComposeError_InsufficientFeeRateImplCopyWith(
          _$TxComposeError_InsufficientFeeRateImpl value,
          $Res Function(_$TxComposeError_InsufficientFeeRateImpl) then) =
      __$$TxComposeError_InsufficientFeeRateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$TxComposeError_InsufficientFeeRateImplCopyWithImpl<$Res>
    extends _$TxComposeErrorCopyWithImpl<$Res,
        _$TxComposeError_InsufficientFeeRateImpl>
    implements _$$TxComposeError_InsufficientFeeRateImplCopyWith<$Res> {
  __$$TxComposeError_InsufficientFeeRateImplCopyWithImpl(
      _$TxComposeError_InsufficientFeeRateImpl _value,
      $Res Function(_$TxComposeError_InsufficientFeeRateImpl) _then)
      : super(_value, _then);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$TxComposeError_InsufficientFeeRateImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$TxComposeError_InsufficientFeeRateImpl
    extends TxComposeError_InsufficientFeeRate {
  const _$TxComposeError_InsufficientFeeRateImpl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'TxComposeError.insufficientFeeRate(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TxComposeError_InsufficientFeeRateImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TxComposeError_InsufficientFeeRateImplCopyWith<
          _$TxComposeError_InsufficientFeeRateImpl>
      get copyWith => __$$TxComposeError_InsufficientFeeRateImplCopyWithImpl<
          _$TxComposeError_InsufficientFeeRateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) coinSelectionError,
    required TResult Function(String field0) error,
    required TResult Function(String field0) insufficientFunds,
    required TResult Function(BigInt field0) insufficientFees,
    required TResult Function(BigInt field0) insufficientFeeRate,
  }) {
    return insufficientFeeRate(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? coinSelectionError,
    TResult? Function(String field0)? error,
    TResult? Function(String field0)? insufficientFunds,
    TResult? Function(BigInt field0)? insufficientFees,
    TResult? Function(BigInt field0)? insufficientFeeRate,
  }) {
    return insufficientFeeRate?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? coinSelectionError,
    TResult Function(String field0)? error,
    TResult Function(String field0)? insufficientFunds,
    TResult Function(BigInt field0)? insufficientFees,
    TResult Function(BigInt field0)? insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (insufficientFeeRate != null) {
      return insufficientFeeRate(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TxComposeError_CoinSelectionError value)
        coinSelectionError,
    required TResult Function(TxComposeError_Error value) error,
    required TResult Function(TxComposeError_InsufficientFunds value)
        insufficientFunds,
    required TResult Function(TxComposeError_InsufficientFees value)
        insufficientFees,
    required TResult Function(TxComposeError_InsufficientFeeRate value)
        insufficientFeeRate,
  }) {
    return insufficientFeeRate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult? Function(TxComposeError_Error value)? error,
    TResult? Function(TxComposeError_InsufficientFunds value)?
        insufficientFunds,
    TResult? Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult? Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
  }) {
    return insufficientFeeRate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TxComposeError_CoinSelectionError value)?
        coinSelectionError,
    TResult Function(TxComposeError_Error value)? error,
    TResult Function(TxComposeError_InsufficientFunds value)? insufficientFunds,
    TResult Function(TxComposeError_InsufficientFees value)? insufficientFees,
    TResult Function(TxComposeError_InsufficientFeeRate value)?
        insufficientFeeRate,
    required TResult orElse(),
  }) {
    if (insufficientFeeRate != null) {
      return insufficientFeeRate(this);
    }
    return orElse();
  }
}

abstract class TxComposeError_InsufficientFeeRate extends TxComposeError {
  const factory TxComposeError_InsufficientFeeRate(final BigInt field0) =
      _$TxComposeError_InsufficientFeeRateImpl;
  const TxComposeError_InsufficientFeeRate._() : super._();

  @override
  BigInt get field0;

  /// Create a copy of TxComposeError
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TxComposeError_InsufficientFeeRateImplCopyWith<
          _$TxComposeError_InsufficientFeeRateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
