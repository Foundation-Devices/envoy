// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bip39.dart';
import 'api/envoy_account.dart';
import 'api/envoy_wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/ngwallet/config.dart';
import 'third_party/ngwallet/transaction.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiEnvoyWalletInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 1478230120;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_ngwallet',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerApplyUpdate(
      {required EnvoyAccountHandler that, required WalletUpdate update});

  ArcMutexNgAccountConnection
      crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetNgAccount(
          {required EnvoyAccountHandler that});

  RustStreamSink<EnvoyAccount>?
      crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetStreamSink(
          {required EnvoyAccountHandler that});

  void crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetNgAccount(
      {required EnvoyAccountHandler that,
      required ArcMutexNgAccountConnection ngAccount});

  void crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetStreamSink(
      {required EnvoyAccountHandler that,
      RustStreamSink<EnvoyAccount>? streamSink});

  BigInt crateApiEnvoyWalletEnvoyAccountHandlerBalance(
      {required EnvoyAccountHandler that});

  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerBroadcast(
      {required EnvoyAccountHandler that,
      required String psbt,
      required String electrumServer});

  NgAccountConfig crateApiEnvoyWalletEnvoyAccountHandlerConfig(
      {required EnvoyAccountHandler that});

  bool crateApiEnvoyWalletEnvoyAccountHandlerIsHot(
      {required EnvoyAccountHandler that});

  Future<EnvoyAccountHandler> crateApiEnvoyWalletEnvoyAccountHandlerMigrate(
      {required String name,
      required String id,
      String? deviceSerial,
      String? dateAdded,
      required AddressType addressType,
      required String color,
      required int index,
      required String internalDescriptor,
      required String externalDescriptor,
      required String dbPath,
      required String sledDbPath,
      required Network network});

  Future<EnvoyAccountHandler>
      crateApiEnvoyWalletEnvoyAccountHandlerNewFromDescriptor(
          {required String name,
          String? deviceSerial,
          String? dateAdded,
          required AddressType addressType,
          required String color,
          required int index,
          required String internalDescriptor,
          required String externalDescriptor,
          required String dbPath,
          required Network network,
          required String id});

  Future<String> crateApiEnvoyWalletEnvoyAccountHandlerNextAddress(
      {required EnvoyAccountHandler that});

  Future<EnvoyAccountHandler> crateApiEnvoyWalletEnvoyAccountHandlerOpenWallet(
      {required String dbPath});

  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerRenameAccount(
      {required EnvoyAccountHandler that, required String name});

  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerRenameTag(
      {required EnvoyAccountHandler that,
      required String existingTag,
      String? newTag});

  Future<FullScanRequest> crateApiEnvoyWalletEnvoyAccountHandlerRequestFullScan(
      {required EnvoyAccountHandler that});

  Future<SyncRequest> crateApiEnvoyWalletEnvoyAccountHandlerRequestSync(
      {required EnvoyAccountHandler that});

  Future<WalletUpdate> crateApiEnvoyWalletEnvoyAccountHandlerScan(
      {required FullScanRequest scanRequest,
      required String electrumServer,
      int? torPort});

  Future<String> crateApiEnvoyWalletEnvoyAccountHandlerSend(
      {required EnvoyAccountHandler that,
      required String address,
      required BigInt amount});

  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerSendUpdate(
      {required EnvoyAccountHandler that});

  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpend(
      {required EnvoyAccountHandler that,
      required Output utxo,
      required bool doNotSpend});

  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendMultiple(
      {required EnvoyAccountHandler that,
      required List<String> utxo,
      required bool doNotSpend});

  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetNote(
      {required EnvoyAccountHandler that,
      required String txId,
      required String note});

  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetTag(
      {required EnvoyAccountHandler that,
      required Output utxo,
      required String tag});

  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerSetTagMultiple(
      {required EnvoyAccountHandler that,
      required List<String> utxo,
      required String tag});

  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetTags(
      {required EnvoyAccountHandler that,
      required List<Output> utxo,
      required String tag});

  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountHandlerState(
      {required EnvoyAccountHandler that});

  Stream<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountHandlerStream(
      {required EnvoyAccountHandler that});

  Future<WalletUpdate> crateApiEnvoyWalletEnvoyAccountHandlerSyncWallet(
      {required SyncRequest syncRequest,
      required String electrumServer,
      int? torPort});

  Future<List<BitcoinTransaction>>
      crateApiEnvoyWalletEnvoyAccountHandlerTransactions(
          {required EnvoyAccountHandler that});

  Future<List<Output>> crateApiEnvoyWalletEnvoyAccountHandlerUtxo(
      {required EnvoyAccountHandler that});

  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerValidateAddress(
      {required String address, Network? network});

  Future<DescriptorFromSeed> crateApiBip39EnvoyBip39DeriveDescriptorFromSeed(
      {required String seedWords,
      required Network network,
      required AddressType addressType,
      required String derivationPath,
      String? passphrase});

  Future<Seed> crateApiBip39EnvoyBip39GenerateSeed({required Network network});

  Future<bool> crateApiBip39EnvoyBip39ValidateSeed({required String seedWords});

  Future<void> crateApiEnvoyWalletInitApp();

  Future<NgAccountConfig> ngwalletConfigNgAccountConfigDeserialize(
      {required String data});

  Future<bool> ngwalletConfigNgAccountConfigIsHot(
      {required NgAccountConfig that});

  Future<NgAccountConfig> ngwalletConfigNgAccountConfigNew(
      {required String name,
      required String color,
      String? deviceSerial,
      String? dateAdded,
      required int index,
      required String internalDescriptor,
      String? externalDescriptor,
      required AddressType addressType,
      required Network network,
      required String id,
      String? dateSynced,
      String? walletPath});

  Future<String> ngwalletConfigNgAccountConfigSerialize(
      {required NgAccountConfig that});

  String ngwalletTransactionOutputGetId({required Output that});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexNgAccountConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexNgAccountConnection;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcMutexNgAccountConnectionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FullScanRequest;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FullScanRequest;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_FullScanRequestPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SyncRequest;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SyncRequest;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SyncRequestPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WalletUpdate;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WalletUpdate;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WalletUpdatePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EnvoyAccountHandler;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EnvoyAccountHandler;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_EnvoyAccountHandlerPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerApplyUpdate(
      {required EnvoyAccountHandler that, required WalletUpdate update}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
            update, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerApplyUpdateConstMeta,
      argValues: [that, update],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerApplyUpdateConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_apply_update",
            argNames: ["that", "update"],
          );

  @override
  ArcMutexNgAccountConnection
      crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetNgAccount(
          {required EnvoyAccountHandler that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetNgAccountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetNgAccountConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_auto_accessor_get_ng_account",
            argNames: ["that"],
          );

  @override
  RustStreamSink<EnvoyAccount>?
      crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetStreamSink(
          {required EnvoyAccountHandler that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_StreamSink_envoy_account_Sse,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetStreamSinkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetStreamSinkConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_auto_accessor_get_stream_sink",
            argNames: ["that"],
          );

  @override
  void crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetNgAccount(
      {required EnvoyAccountHandler that,
      required ArcMutexNgAccountConnection ngAccount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
            ngAccount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetNgAccountConstMeta,
      argValues: [that, ngAccount],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetNgAccountConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_auto_accessor_set_ng_account",
            argNames: ["that", "ngAccount"],
          );

  @override
  void crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetStreamSink(
      {required EnvoyAccountHandler that,
      RustStreamSink<EnvoyAccount>? streamSink}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_opt_StreamSink_envoy_account_Sse(streamSink, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetStreamSinkConstMeta,
      argValues: [that, streamSink],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetStreamSinkConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_auto_accessor_set_stream_sink",
            argNames: ["that", "streamSink"],
          );

  @override
  BigInt crateApiEnvoyWalletEnvoyAccountHandlerBalance(
      {required EnvoyAccountHandler that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerBalanceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerBalanceConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_balance",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerBroadcast(
      {required EnvoyAccountHandler that,
      required String psbt,
      required String electrumServer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_String(psbt, serializer);
        sse_encode_String(electrumServer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerBroadcastConstMeta,
      argValues: [that, psbt, electrumServer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerBroadcastConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_broadcast",
        argNames: ["that", "psbt", "electrumServer"],
      );

  @override
  NgAccountConfig crateApiEnvoyWalletEnvoyAccountHandlerConfig(
      {required EnvoyAccountHandler that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ng_account_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerConfigConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerConfigConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_config",
        argNames: ["that"],
      );

  @override
  bool crateApiEnvoyWalletEnvoyAccountHandlerIsHot(
      {required EnvoyAccountHandler that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerIsHotConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerIsHotConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_is_hot",
        argNames: ["that"],
      );

  @override
  Future<EnvoyAccountHandler> crateApiEnvoyWalletEnvoyAccountHandlerMigrate(
      {required String name,
      required String id,
      String? deviceSerial,
      String? dateAdded,
      required AddressType addressType,
      required String color,
      required int index,
      required String internalDescriptor,
      required String externalDescriptor,
      required String dbPath,
      required String sledDbPath,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_String(id, serializer);
        sse_encode_opt_String(deviceSerial, serializer);
        sse_encode_opt_String(dateAdded, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_String(color, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_String(internalDescriptor, serializer);
        sse_encode_String(externalDescriptor, serializer);
        sse_encode_String(dbPath, serializer);
        sse_encode_String(sledDbPath, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerMigrateConstMeta,
      argValues: [
        name,
        id,
        deviceSerial,
        dateAdded,
        addressType,
        color,
        index,
        internalDescriptor,
        externalDescriptor,
        dbPath,
        sledDbPath,
        network
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerMigrateConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_migrate",
        argNames: [
          "name",
          "id",
          "deviceSerial",
          "dateAdded",
          "addressType",
          "color",
          "index",
          "internalDescriptor",
          "externalDescriptor",
          "dbPath",
          "sledDbPath",
          "network"
        ],
      );

  @override
  Future<EnvoyAccountHandler>
      crateApiEnvoyWalletEnvoyAccountHandlerNewFromDescriptor(
          {required String name,
          String? deviceSerial,
          String? dateAdded,
          required AddressType addressType,
          required String color,
          required int index,
          required String internalDescriptor,
          required String externalDescriptor,
          required String dbPath,
          required Network network,
          required String id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_opt_String(deviceSerial, serializer);
        sse_encode_opt_String(dateAdded, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_String(color, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_String(internalDescriptor, serializer);
        sse_encode_String(externalDescriptor, serializer);
        sse_encode_String(dbPath, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerNewFromDescriptorConstMeta,
      argValues: [
        name,
        deviceSerial,
        dateAdded,
        addressType,
        color,
        index,
        internalDescriptor,
        externalDescriptor,
        dbPath,
        network,
        id
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerNewFromDescriptorConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_new_from_descriptor",
            argNames: [
              "name",
              "deviceSerial",
              "dateAdded",
              "addressType",
              "color",
              "index",
              "internalDescriptor",
              "externalDescriptor",
              "dbPath",
              "network",
              "id"
            ],
          );

  @override
  Future<String> crateApiEnvoyWalletEnvoyAccountHandlerNextAddress(
      {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerNextAddressConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerNextAddressConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_next_address",
            argNames: ["that"],
          );

  @override
  Future<EnvoyAccountHandler> crateApiEnvoyWalletEnvoyAccountHandlerOpenWallet(
      {required String dbPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dbPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerOpenWalletConstMeta,
      argValues: [dbPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerOpenWalletConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_open_wallet",
            argNames: ["dbPath"],
          );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerRenameAccount(
      {required EnvoyAccountHandler that, required String name}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_String(name, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerRenameAccountConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerRenameAccountConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_rename_account",
            argNames: ["that", "name"],
          );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerRenameTag(
      {required EnvoyAccountHandler that,
      required String existingTag,
      String? newTag}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_String(existingTag, serializer);
        sse_encode_opt_String(newTag, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerRenameTagConstMeta,
      argValues: [that, existingTag, newTag],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerRenameTagConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_rename_tag",
        argNames: ["that", "existingTag", "newTag"],
      );

  @override
  Future<FullScanRequest> crateApiEnvoyWalletEnvoyAccountHandlerRequestFullScan(
      {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerRequestFullScanConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerRequestFullScanConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_request_full_scan",
            argNames: ["that"],
          );

  @override
  Future<SyncRequest> crateApiEnvoyWalletEnvoyAccountHandlerRequestSync(
      {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerRequestSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerRequestSyncConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_request_sync",
            argNames: ["that"],
          );

  @override
  Future<WalletUpdate> crateApiEnvoyWalletEnvoyAccountHandlerScan(
      {required FullScanRequest scanRequest,
      required String electrumServer,
      int? torPort}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
            scanRequest, serializer);
        sse_encode_String(electrumServer, serializer);
        sse_encode_opt_box_autoadd_u_16(torPort, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerScanConstMeta,
      argValues: [scanRequest, electrumServer, torPort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerScanConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_scan",
        argNames: ["scanRequest", "electrumServer", "torPort"],
      );

  @override
  Future<String> crateApiEnvoyWalletEnvoyAccountHandlerSend(
      {required EnvoyAccountHandler that,
      required String address,
      required BigInt amount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_String(address, serializer);
        sse_encode_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSendConstMeta,
      argValues: [that, address, amount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerSendConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_send",
        argNames: ["that", "address", "amount"],
      );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerSendUpdate(
      {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSendUpdateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerSendUpdateConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_send_update",
            argNames: ["that"],
          );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpend(
      {required EnvoyAccountHandler that,
      required Output utxo,
      required bool doNotSpend}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_box_autoadd_output(utxo, serializer);
        sse_encode_bool(doNotSpend, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendConstMeta,
      argValues: [that, utxo, doNotSpend],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_set_do_not_spend",
            argNames: ["that", "utxo", "doNotSpend"],
          );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendMultiple(
      {required EnvoyAccountHandler that,
      required List<String> utxo,
      required bool doNotSpend}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_list_String(utxo, serializer);
        sse_encode_bool(doNotSpend, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendMultipleConstMeta,
      argValues: [that, utxo, doNotSpend],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendMultipleConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_set_do_not_spend_multiple",
            argNames: ["that", "utxo", "doNotSpend"],
          );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetNote(
      {required EnvoyAccountHandler that,
      required String txId,
      required String note}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_String(txId, serializer);
        sse_encode_String(note, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSetNoteConstMeta,
      argValues: [that, txId, note],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerSetNoteConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_set_note",
        argNames: ["that", "txId", "note"],
      );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetTag(
      {required EnvoyAccountHandler that,
      required Output utxo,
      required String tag}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_box_autoadd_output(utxo, serializer);
        sse_encode_String(tag, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSetTagConstMeta,
      argValues: [that, utxo, tag],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerSetTagConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_set_tag",
        argNames: ["that", "utxo", "tag"],
      );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountHandlerSetTagMultiple(
      {required EnvoyAccountHandler that,
      required List<String> utxo,
      required String tag}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_list_String(utxo, serializer);
        sse_encode_String(tag, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSetTagMultipleConstMeta,
      argValues: [that, utxo, tag],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerSetTagMultipleConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_set_tag_multiple",
            argNames: ["that", "utxo", "tag"],
          );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerSetTags(
      {required EnvoyAccountHandler that,
      required List<Output> utxo,
      required String tag}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_list_output(utxo, serializer);
        sse_encode_String(tag, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSetTagsConstMeta,
      argValues: [that, utxo, tag],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerSetTagsConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_set_tags",
        argNames: ["that", "utxo", "tag"],
      );

  @override
  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountHandlerState(
      {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_envoy_account,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerStateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerStateConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_state",
        argNames: ["that"],
      );

  @override
  Stream<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountHandlerStream(
      {required EnvoyAccountHandler that}) {
    final streamSink = RustStreamSink<EnvoyAccount>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        sse_encode_StreamSink_envoy_account_Sse(streamSink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerStreamConstMeta,
      argValues: [that, streamSink],
      apiImpl: this,
    )));
    return streamSink.stream;
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerStreamConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_stream",
        argNames: ["that", "streamSink"],
      );

  @override
  Future<WalletUpdate> crateApiEnvoyWalletEnvoyAccountHandlerSyncWallet(
      {required SyncRequest syncRequest,
      required String electrumServer,
      int? torPort}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
            syncRequest, serializer);
        sse_encode_String(electrumServer, serializer);
        sse_encode_opt_box_autoadd_u_16(torPort, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerSyncWalletConstMeta,
      argValues: [syncRequest, electrumServer, torPort],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerSyncWalletConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_sync_wallet",
            argNames: ["syncRequest", "electrumServer", "torPort"],
          );

  @override
  Future<List<BitcoinTransaction>>
      crateApiEnvoyWalletEnvoyAccountHandlerTransactions(
          {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_bitcoin_transaction,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerTransactionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerTransactionsConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_transactions",
            argNames: ["that"],
          );

  @override
  Future<List<Output>> crateApiEnvoyWalletEnvoyAccountHandlerUtxo(
      {required EnvoyAccountHandler that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_output,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountHandlerUtxoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountHandlerUtxoConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccountHandler_utxo",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountHandlerValidateAddress(
      {required String address, Network? network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(address, serializer);
        sse_encode_opt_box_autoadd_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountHandlerValidateAddressConstMeta,
      argValues: [address, network],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountHandlerValidateAddressConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccountHandler_validate_address",
            argNames: ["address", "network"],
          );

  @override
  Future<DescriptorFromSeed> crateApiBip39EnvoyBip39DeriveDescriptorFromSeed(
      {required String seedWords,
      required Network network,
      required AddressType addressType,
      required String derivationPath,
      String? passphrase}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(seedWords, serializer);
        sse_encode_network(network, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_String(derivationPath, serializer);
        sse_encode_opt_String(passphrase, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_descriptor_from_seed,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBip39EnvoyBip39DeriveDescriptorFromSeedConstMeta,
      argValues: [seedWords, network, addressType, derivationPath, passphrase],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBip39EnvoyBip39DeriveDescriptorFromSeedConstMeta =>
      const TaskConstMeta(
        debugName: "envoy_bip_39_derive_descriptor_from_seed",
        argNames: [
          "seedWords",
          "network",
          "addressType",
          "derivationPath",
          "passphrase"
        ],
      );

  @override
  Future<Seed> crateApiBip39EnvoyBip39GenerateSeed({required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_seed,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBip39EnvoyBip39GenerateSeedConstMeta,
      argValues: [network],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBip39EnvoyBip39GenerateSeedConstMeta =>
      const TaskConstMeta(
        debugName: "envoy_bip_39_generate_seed",
        argNames: ["network"],
      );

  @override
  Future<bool> crateApiBip39EnvoyBip39ValidateSeed(
      {required String seedWords}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(seedWords, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBip39EnvoyBip39ValidateSeedConstMeta,
      argValues: [seedWords],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBip39EnvoyBip39ValidateSeedConstMeta =>
      const TaskConstMeta(
        debugName: "envoy_bip_39_validate_seed",
        argNames: ["seedWords"],
      );

  @override
  Future<void> crateApiEnvoyWalletInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<NgAccountConfig> ngwalletConfigNgAccountConfigDeserialize(
      {required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ng_account_config,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigDeserializeConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigDeserializeConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_deserialize",
        argNames: ["data"],
      );

  @override
  Future<bool> ngwalletConfigNgAccountConfigIsHot(
      {required NgAccountConfig that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ng_account_config(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigIsHotConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigIsHotConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_is_hot",
        argNames: ["that"],
      );

  @override
  Future<NgAccountConfig> ngwalletConfigNgAccountConfigNew(
      {required String name,
      required String color,
      String? deviceSerial,
      String? dateAdded,
      required int index,
      required String internalDescriptor,
      String? externalDescriptor,
      required AddressType addressType,
      required Network network,
      required String id,
      String? dateSynced,
      String? walletPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_String(color, serializer);
        sse_encode_opt_String(deviceSerial, serializer);
        sse_encode_opt_String(dateAdded, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_String(internalDescriptor, serializer);
        sse_encode_opt_String(externalDescriptor, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(id, serializer);
        sse_encode_opt_String(dateSynced, serializer);
        sse_encode_opt_String(walletPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ng_account_config,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigNewConstMeta,
      argValues: [
        name,
        color,
        deviceSerial,
        dateAdded,
        index,
        internalDescriptor,
        externalDescriptor,
        addressType,
        network,
        id,
        dateSynced,
        walletPath
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigNewConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_new",
        argNames: [
          "name",
          "color",
          "deviceSerial",
          "dateAdded",
          "index",
          "internalDescriptor",
          "externalDescriptor",
          "addressType",
          "network",
          "id",
          "dateSynced",
          "walletPath"
        ],
      );

  @override
  Future<String> ngwalletConfigNgAccountConfigSerialize(
      {required NgAccountConfig that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ng_account_config(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_serialize",
        argNames: ["that"],
      );

  @override
  String ngwalletTransactionOutputGetId({required Output that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_output(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletTransactionOutputGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletTransactionOutputGetIdConstMeta =>
      const TaskConstMeta(
        debugName: "output_get_id",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexNgAccountConnection => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexNgAccountConnection => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FullScanRequest => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FullScanRequest => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SyncRequest => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SyncRequest => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WalletUpdate => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WalletUpdate => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EnvoyAccountHandler => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EnvoyAccountHandler => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ArcMutexNgAccountConnection
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  FullScanRequest
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullScanRequestImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SyncRequest
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SyncRequestImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WalletUpdate
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WalletUpdateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EnvoyAccountHandler
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EnvoyAccountHandler
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EnvoyAccountHandler
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcMutexNgAccountConnection
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  FullScanRequest
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullScanRequestImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SyncRequest
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SyncRequestImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WalletUpdate
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WalletUpdateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EnvoyAccountHandler
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<EnvoyAccount> dco_decode_StreamSink_envoy_account_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressType dco_decode_address_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressType.values[raw as int];
  }

  @protected
  BitcoinTransaction dco_decode_bitcoin_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return BitcoinTransaction(
      txId: dco_decode_String(arr[0]),
      blockHeight: dco_decode_u_32(arr[1]),
      confirmations: dco_decode_u_32(arr[2]),
      isConfirmed: dco_decode_bool(arr[3]),
      fee: dco_decode_u_64(arr[4]),
      amount: dco_decode_i_64(arr[5]),
      inputs: dco_decode_list_input(arr[6]),
      address: dco_decode_String(arr[7]),
      outputs: dco_decode_list_output(arr[8]),
      note: dco_decode_opt_String(arr[9]),
      date: dco_decode_opt_box_autoadd_u_64(arr[10]),
      vsize: dco_decode_usize(arr[11]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Network dco_decode_box_autoadd_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_network(raw);
  }

  @protected
  NgAccountConfig dco_decode_box_autoadd_ng_account_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ng_account_config(raw);
  }

  @protected
  Output dco_decode_box_autoadd_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_output(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  DescriptorFromSeed dco_decode_descriptor_from_seed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return DescriptorFromSeed(
      externalDescriptor: dco_decode_String(arr[0]),
      internalDescriptor: dco_decode_String(arr[1]),
      externalPubDescriptor: dco_decode_String(arr[2]),
      internalPubDescriptor: dco_decode_String(arr[3]),
    );
  }

  @protected
  EnvoyAccount dco_decode_envoy_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 18)
      throw Exception('unexpected arr length: expect 18 but see ${arr.length}');
    return EnvoyAccount(
      name: dco_decode_String(arr[0]),
      color: dco_decode_String(arr[1]),
      deviceSerial: dco_decode_opt_String(arr[2]),
      dateAdded: dco_decode_opt_String(arr[3]),
      addressType: dco_decode_address_type(arr[4]),
      index: dco_decode_u_32(arr[5]),
      internalDescriptor: dco_decode_String(arr[6]),
      externalDescriptor: dco_decode_opt_String(arr[7]),
      dateSynced: dco_decode_opt_String(arr[8]),
      walletPath: dco_decode_opt_String(arr[9]),
      network: dco_decode_network(arr[10]),
      id: dco_decode_String(arr[11]),
      nextAddress: dco_decode_String(arr[12]),
      balance: dco_decode_u_64(arr[13]),
      isHot: dco_decode_bool(arr[14]),
      transactions: dco_decode_list_bitcoin_transaction(arr[15]),
      utxo: dco_decode_list_output(arr[16]),
      tags: dco_decode_list_String(arr[17]),
    );
  }

  @protected
  EnvoyBip39 dco_decode_envoy_bip_39(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return EnvoyBip39();
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Input dco_decode_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Input(
      txId: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<BitcoinTransaction> dco_decode_list_bitcoin_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bitcoin_transaction).toList();
  }

  @protected
  List<Input> dco_decode_list_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_input).toList();
  }

  @protected
  List<Output> dco_decode_list_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_output).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NgAccountConfig dco_decode_ng_account_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return NgAccountConfig(
      name: dco_decode_String(arr[0]),
      color: dco_decode_String(arr[1]),
      deviceSerial: dco_decode_opt_String(arr[2]),
      dateAdded: dco_decode_opt_String(arr[3]),
      addressType: dco_decode_address_type(arr[4]),
      index: dco_decode_u_32(arr[5]),
      internalDescriptor: dco_decode_String(arr[6]),
      externalDescriptor: dco_decode_opt_String(arr[7]),
      dateSynced: dco_decode_opt_String(arr[8]),
      walletPath: dco_decode_opt_String(arr[9]),
      network: dco_decode_network(arr[10]),
      id: dco_decode_String(arr[11]),
    );
  }

  @protected
  RustStreamSink<EnvoyAccount>? dco_decode_opt_StreamSink_envoy_account_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_StreamSink_envoy_account_Sse(raw);
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Network? dco_decode_opt_box_autoadd_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_network(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Output dco_decode_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Output(
      txId: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
      amount: dco_decode_u_64(arr[2]),
      tag: dco_decode_opt_String(arr[3]),
      date: dco_decode_opt_box_autoadd_u_64(arr[4]),
      isConfirmed: dco_decode_bool(arr[5]),
      address: dco_decode_String(arr[6]),
      doNotSpend: dco_decode_bool(arr[7]),
    );
  }

  @protected
  Seed dco_decode_seed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Seed(
      mnemonic: dco_decode_String(arr[0]),
      xprv: dco_decode_String(arr[1]),
      fingerprint: dco_decode_String(arr[2]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ArcMutexNgAccountConnection
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FullScanRequest
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullScanRequestImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SyncRequest
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SyncRequestImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WalletUpdate
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WalletUpdateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccountHandler
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccountHandler
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccountHandler
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcMutexNgAccountConnection
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FullScanRequest
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullScanRequestImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SyncRequest
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SyncRequestImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WalletUpdate
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WalletUpdateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccountHandler
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountHandlerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RustStreamSink<EnvoyAccount> sse_decode_StreamSink_envoy_account_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressType sse_decode_address_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AddressType.values[inner];
  }

  @protected
  BitcoinTransaction sse_decode_bitcoin_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_blockHeight = sse_decode_u_32(deserializer);
    var var_confirmations = sse_decode_u_32(deserializer);
    var var_isConfirmed = sse_decode_bool(deserializer);
    var var_fee = sse_decode_u_64(deserializer);
    var var_amount = sse_decode_i_64(deserializer);
    var var_inputs = sse_decode_list_input(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_outputs = sse_decode_list_output(deserializer);
    var var_note = sse_decode_opt_String(deserializer);
    var var_date = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_vsize = sse_decode_usize(deserializer);
    return BitcoinTransaction(
        txId: var_txId,
        blockHeight: var_blockHeight,
        confirmations: var_confirmations,
        isConfirmed: var_isConfirmed,
        fee: var_fee,
        amount: var_amount,
        inputs: var_inputs,
        address: var_address,
        outputs: var_outputs,
        note: var_note,
        date: var_date,
        vsize: var_vsize);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Network sse_decode_box_autoadd_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_network(deserializer));
  }

  @protected
  NgAccountConfig sse_decode_box_autoadd_ng_account_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ng_account_config(deserializer));
  }

  @protected
  Output sse_decode_box_autoadd_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_output(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  DescriptorFromSeed sse_decode_descriptor_from_seed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_externalDescriptor = sse_decode_String(deserializer);
    var var_internalDescriptor = sse_decode_String(deserializer);
    var var_externalPubDescriptor = sse_decode_String(deserializer);
    var var_internalPubDescriptor = sse_decode_String(deserializer);
    return DescriptorFromSeed(
        externalDescriptor: var_externalDescriptor,
        internalDescriptor: var_internalDescriptor,
        externalPubDescriptor: var_externalPubDescriptor,
        internalPubDescriptor: var_internalPubDescriptor);
  }

  @protected
  EnvoyAccount sse_decode_envoy_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_color = sse_decode_String(deserializer);
    var var_deviceSerial = sse_decode_opt_String(deserializer);
    var var_dateAdded = sse_decode_opt_String(deserializer);
    var var_addressType = sse_decode_address_type(deserializer);
    var var_index = sse_decode_u_32(deserializer);
    var var_internalDescriptor = sse_decode_String(deserializer);
    var var_externalDescriptor = sse_decode_opt_String(deserializer);
    var var_dateSynced = sse_decode_opt_String(deserializer);
    var var_walletPath = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_id = sse_decode_String(deserializer);
    var var_nextAddress = sse_decode_String(deserializer);
    var var_balance = sse_decode_u_64(deserializer);
    var var_isHot = sse_decode_bool(deserializer);
    var var_transactions = sse_decode_list_bitcoin_transaction(deserializer);
    var var_utxo = sse_decode_list_output(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    return EnvoyAccount(
        name: var_name,
        color: var_color,
        deviceSerial: var_deviceSerial,
        dateAdded: var_dateAdded,
        addressType: var_addressType,
        index: var_index,
        internalDescriptor: var_internalDescriptor,
        externalDescriptor: var_externalDescriptor,
        dateSynced: var_dateSynced,
        walletPath: var_walletPath,
        network: var_network,
        id: var_id,
        nextAddress: var_nextAddress,
        balance: var_balance,
        isHot: var_isHot,
        transactions: var_transactions,
        utxo: var_utxo,
        tags: var_tags);
  }

  @protected
  EnvoyBip39 sse_decode_envoy_bip_39(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyBip39();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Input sse_decode_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return Input(txId: var_txId, vout: var_vout);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<BitcoinTransaction> sse_decode_list_bitcoin_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BitcoinTransaction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bitcoin_transaction(deserializer));
    }
    return ans_;
  }

  @protected
  List<Input> sse_decode_list_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Input>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_input(deserializer));
    }
    return ans_;
  }

  @protected
  List<Output> sse_decode_list_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Output>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_output(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NgAccountConfig sse_decode_ng_account_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_color = sse_decode_String(deserializer);
    var var_deviceSerial = sse_decode_opt_String(deserializer);
    var var_dateAdded = sse_decode_opt_String(deserializer);
    var var_addressType = sse_decode_address_type(deserializer);
    var var_index = sse_decode_u_32(deserializer);
    var var_internalDescriptor = sse_decode_String(deserializer);
    var var_externalDescriptor = sse_decode_opt_String(deserializer);
    var var_dateSynced = sse_decode_opt_String(deserializer);
    var var_walletPath = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_id = sse_decode_String(deserializer);
    return NgAccountConfig(
        name: var_name,
        color: var_color,
        deviceSerial: var_deviceSerial,
        dateAdded: var_dateAdded,
        addressType: var_addressType,
        index: var_index,
        internalDescriptor: var_internalDescriptor,
        externalDescriptor: var_externalDescriptor,
        dateSynced: var_dateSynced,
        walletPath: var_walletPath,
        network: var_network,
        id: var_id);
  }

  @protected
  RustStreamSink<EnvoyAccount>? sse_decode_opt_StreamSink_envoy_account_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_StreamSink_envoy_account_Sse(deserializer));
    } else {
      return null;
    }
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Network? sse_decode_opt_box_autoadd_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_network(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Output sse_decode_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_tag = sse_decode_opt_String(deserializer);
    var var_date = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_isConfirmed = sse_decode_bool(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_doNotSpend = sse_decode_bool(deserializer);
    return Output(
        txId: var_txId,
        vout: var_vout,
        amount: var_amount,
        tag: var_tag,
        date: var_date,
        isConfirmed: var_isConfirmed,
        address: var_address,
        doNotSpend: var_doNotSpend);
  }

  @protected
  Seed sse_decode_seed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_mnemonic = sse_decode_String(deserializer);
    var var_xprv = sse_decode_String(deserializer);
    var var_fingerprint = sse_decode_String(deserializer);
    return Seed(
        mnemonic: var_mnemonic, xprv: var_xprv, fingerprint: var_fingerprint);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          ArcMutexNgAccountConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexNgAccountConnectionImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          FullScanRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullScanRequestImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
          SyncRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SyncRequestImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
          WalletUpdate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as WalletUpdateImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          EnvoyAccountHandler self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountHandlerImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          EnvoyAccountHandler self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountHandlerImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          EnvoyAccountHandler self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountHandlerImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          ArcMutexNgAccountConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexNgAccountConnectionImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          FullScanRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullScanRequestImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionSyncRequestKeychainKindu32(
          SyncRequest self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SyncRequestImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexUpdate(
          WalletUpdate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as WalletUpdateImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccountHandler(
          EnvoyAccountHandler self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountHandlerImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_envoy_account_Sse(
      RustStreamSink<EnvoyAccount> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_envoy_account,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_type(AddressType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bitcoin_transaction(
      BitcoinTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_u_32(self.blockHeight, serializer);
    sse_encode_u_32(self.confirmations, serializer);
    sse_encode_bool(self.isConfirmed, serializer);
    sse_encode_u_64(self.fee, serializer);
    sse_encode_i_64(self.amount, serializer);
    sse_encode_list_input(self.inputs, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_list_output(self.outputs, serializer);
    sse_encode_opt_String(self.note, serializer);
    sse_encode_opt_box_autoadd_u_64(self.date, serializer);
    sse_encode_usize(self.vsize, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_network(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ng_account_config(
      NgAccountConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ng_account_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_output(Output self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_output(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_descriptor_from_seed(
      DescriptorFromSeed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.externalDescriptor, serializer);
    sse_encode_String(self.internalDescriptor, serializer);
    sse_encode_String(self.externalPubDescriptor, serializer);
    sse_encode_String(self.internalPubDescriptor, serializer);
  }

  @protected
  void sse_encode_envoy_account(EnvoyAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.color, serializer);
    sse_encode_opt_String(self.deviceSerial, serializer);
    sse_encode_opt_String(self.dateAdded, serializer);
    sse_encode_address_type(self.addressType, serializer);
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.internalDescriptor, serializer);
    sse_encode_opt_String(self.externalDescriptor, serializer);
    sse_encode_opt_String(self.dateSynced, serializer);
    sse_encode_opt_String(self.walletPath, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.nextAddress, serializer);
    sse_encode_u_64(self.balance, serializer);
    sse_encode_bool(self.isHot, serializer);
    sse_encode_list_bitcoin_transaction(self.transactions, serializer);
    sse_encode_list_output(self.utxo, serializer);
    sse_encode_list_String(self.tags, serializer);
  }

  @protected
  void sse_encode_envoy_bip_39(EnvoyBip39 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_input(Input self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bitcoin_transaction(
      List<BitcoinTransaction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bitcoin_transaction(item, serializer);
    }
  }

  @protected
  void sse_encode_list_input(List<Input> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_input(item, serializer);
    }
  }

  @protected
  void sse_encode_list_output(List<Output> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_output(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ng_account_config(
      NgAccountConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.color, serializer);
    sse_encode_opt_String(self.deviceSerial, serializer);
    sse_encode_opt_String(self.dateAdded, serializer);
    sse_encode_address_type(self.addressType, serializer);
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.internalDescriptor, serializer);
    sse_encode_opt_String(self.externalDescriptor, serializer);
    sse_encode_opt_String(self.dateSynced, serializer);
    sse_encode_opt_String(self.walletPath, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.id, serializer);
  }

  @protected
  void sse_encode_opt_StreamSink_envoy_account_Sse(
      RustStreamSink<EnvoyAccount>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_StreamSink_envoy_account_Sse(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_network(
      Network? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_network(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_output(Output self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_u_32(self.vout, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_opt_String(self.tag, serializer);
    sse_encode_opt_box_autoadd_u_64(self.date, serializer);
    sse_encode_bool(self.isConfirmed, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_bool(self.doNotSpend, serializer);
  }

  @protected
  void sse_encode_seed(Seed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.mnemonic, serializer);
    sse_encode_String(self.xprv, serializer);
    sse_encode_String(self.fingerprint, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class ArcMutexNgAccountConnectionImpl extends RustOpaque
    implements ArcMutexNgAccountConnection {
  // Not to be used by end users
  ArcMutexNgAccountConnectionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcMutexNgAccountConnectionImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_ArcMutexNgAccountConnection,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexNgAccountConnection,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexNgAccountConnectionPtr,
  );
}

@sealed
class EnvoyAccountHandlerImpl extends RustOpaque
    implements EnvoyAccountHandler {
  // Not to be used by end users
  EnvoyAccountHandlerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  EnvoyAccountHandlerImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_EnvoyAccountHandler,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_EnvoyAccountHandler,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_EnvoyAccountHandlerPtr,
  );

  Future<bool> applyUpdate({required WalletUpdate update}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerApplyUpdate(
          that: this, update: update);

  ArcMutexNgAccountConnection get ngAccount => RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetNgAccount(
        that: this,
      );

  RustStreamSink<EnvoyAccount>? get streamSink => RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorGetStreamSink(
        that: this,
      );

  set ngAccount(ArcMutexNgAccountConnection ngAccount) => RustLib.instance.api
      .crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetNgAccount(
          that: this, ngAccount: ngAccount);

  set streamSink(RustStreamSink<EnvoyAccount>? streamSink) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerAutoAccessorSetStreamSink(
              that: this, streamSink: streamSink);

  BigInt balance() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerBalance(
        that: this,
      );

  Future<void> broadcast(
          {required String psbt, required String electrumServer}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerBroadcast(
          that: this, psbt: psbt, electrumServer: electrumServer);

  NgAccountConfig config() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerConfig(
        that: this,
      );

  bool isHot() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerIsHot(
        that: this,
      );

  Future<String> nextAddress() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerNextAddress(
        that: this,
      );

  Future<void> renameAccount({required String name}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerRenameAccount(
          that: this, name: name);

  Future<void> renameTag({required String existingTag, String? newTag}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerRenameTag(
          that: this, existingTag: existingTag, newTag: newTag);

  Future<FullScanRequest> requestFullScan() => RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerRequestFullScan(
        that: this,
      );

  Future<SyncRequest> requestSync() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerRequestSync(
        that: this,
      );

  Future<String> send({required String address, required BigInt amount}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSend(
          that: this, address: address, amount: amount);

  Future<void> sendUpdate() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSendUpdate(
        that: this,
      );

  Future<bool> setDoNotSpend(
          {required Output utxo, required bool doNotSpend}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpend(
          that: this, utxo: utxo, doNotSpend: doNotSpend);

  Future<void> setDoNotSpendMultiple(
          {required List<String> utxo, required bool doNotSpend}) =>
      RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountHandlerSetDoNotSpendMultiple(
              that: this, utxo: utxo, doNotSpend: doNotSpend);

  Future<bool> setNote({required String txId, required String note}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSetNote(
          that: this, txId: txId, note: note);

  Future<bool> setTag({required Output utxo, required String tag}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSetTag(
          that: this, utxo: utxo, tag: tag);

  Future<void> setTagMultiple(
          {required List<String> utxo, required String tag}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSetTagMultiple(
          that: this, utxo: utxo, tag: tag);

  Future<bool> setTags({required List<Output> utxo, required String tag}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerSetTags(
          that: this, utxo: utxo, tag: tag);

  Future<EnvoyAccount> state() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerState(
        that: this,
      );

  Stream<EnvoyAccount> stream() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerStream(
        that: this,
      );

  Future<List<BitcoinTransaction>> transactions() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerTransactions(
        that: this,
      );

  Future<List<Output>> utxo() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountHandlerUtxo(
        that: this,
      );
}

@sealed
class FullScanRequestImpl extends RustOpaque implements FullScanRequest {
  // Not to be used by end users
  FullScanRequestImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FullScanRequestImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_FullScanRequest,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_FullScanRequest,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FullScanRequestPtr,
  );
}

@sealed
class SyncRequestImpl extends RustOpaque implements SyncRequest {
  // Not to be used by end users
  SyncRequestImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SyncRequestImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SyncRequest,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SyncRequest,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SyncRequestPtr,
  );
}

@sealed
class WalletUpdateImpl extends RustOpaque implements WalletUpdate {
  // Not to be used by end users
  WalletUpdateImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  WalletUpdateImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_WalletUpdate,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_WalletUpdate,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WalletUpdatePtr,
  );
}
