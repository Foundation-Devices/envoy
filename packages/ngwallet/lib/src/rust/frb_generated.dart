// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/envoy_wallet.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/ngwallet/config.dart';
import 'third_party/ngwallet/transaction.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiEnvoyWalletInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => -1562893570;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_ngwallet',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<bool> crateApiEnvoyWalletEnvoyAccountApplyUpdate(
      {required EnvoyAccount that,
      required ArcMutexOptionFullScanResponseKeychainKind scanRequest});

  ArcMutexNgAccountConnection
      crateApiEnvoyWalletEnvoyAccountAutoAccessorGetNgAccount(
          {required EnvoyAccount that});

  void crateApiEnvoyWalletEnvoyAccountAutoAccessorSetNgAccount(
      {required EnvoyAccount that,
      required ArcMutexNgAccountConnection ngAccount});

  BigInt crateApiEnvoyWalletEnvoyAccountBalance({required EnvoyAccount that});

  Future<void> crateApiEnvoyWalletEnvoyAccountBroadcast(
      {required EnvoyAccount that,
      required String psbt,
      required String electrumServer});

  NgAccountConfig crateApiEnvoyWalletEnvoyAccountConfig(
      {required EnvoyAccount that});

  bool crateApiEnvoyWalletEnvoyAccountIsHot({required EnvoyAccount that});

  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountMigrate(
      {required String name,
      required String id,
      String? deviceSerial,
      String? dateAdded,
      required AddressType addressType,
      required String color,
      required int index,
      required String internalDescriptor,
      required String externalDescriptor,
      required String dbPath,
      required String sledDbPath,
      required Network network});

  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountNewFromDescriptor(
      {required String name,
      String? deviceSerial,
      String? dateAdded,
      required AddressType addressType,
      required String color,
      required int index,
      required String internalDescriptor,
      required String externalDescriptor,
      required String dbPath,
      required Network network,
      required String id});

  Future<String> crateApiEnvoyWalletEnvoyAccountNextAddress(
      {required EnvoyAccount that});

  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountOpenWallet(
      {required String dbPath});

  Future<ArcMutexOptionFullScanRequestKeychainKind>
      crateApiEnvoyWalletEnvoyAccountRequestScan({required EnvoyAccount that});

  Future<ArcMutexOptionFullScanResponseKeychainKind>
      crateApiEnvoyWalletEnvoyAccountScan(
          {required ArcMutexOptionFullScanRequestKeychainKind scanRequest,
          required String electrumServer});

  Future<String> crateApiEnvoyWalletEnvoyAccountSend(
      {required EnvoyAccount that,
      required String address,
      required BigInt amount});

  Future<bool> crateApiEnvoyWalletEnvoyAccountSetDoNotSpend(
      {required EnvoyAccount that,
      required Output utxo,
      required bool doNotSpend});

  Future<bool> crateApiEnvoyWalletEnvoyAccountSetNote(
      {required EnvoyAccount that, required String txId, required String note});

  Future<bool> crateApiEnvoyWalletEnvoyAccountSetTag(
      {required EnvoyAccount that, required Output utxo, required String tag});

  Future<List<BitcoinTransaction>> crateApiEnvoyWalletEnvoyAccountTransactions(
      {required EnvoyAccount that});

  Future<List<Output>> crateApiEnvoyWalletEnvoyAccountUtxo(
      {required EnvoyAccount that});

  Future<void> crateApiEnvoyWalletInitApp();

  Future<NgAccountConfig> ngwalletConfigNgAccountConfigDeserialize(
      {required String data});

  Future<bool> ngwalletConfigNgAccountConfigIsHot(
      {required NgAccountConfig that});

  Future<NgAccountConfig> ngwalletConfigNgAccountConfigNew(
      {required String name,
      required String color,
      String? deviceSerial,
      String? dateAdded,
      required int index,
      required String internalDescriptor,
      String? externalDescriptor,
      required AddressType addressType,
      required Network network,
      required String id,
      String? dateSynced});

  Future<String> ngwalletConfigNgAccountConfigSerialize(
      {required NgAccountConfig that});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexNgAccountConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexNgAccountConnection;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcMutexNgAccountConnectionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexOptionFullScanRequestKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexOptionFullScanRequestKeychainKind;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcMutexOptionFullScanRequestKeychainKindPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexOptionFullScanResponseKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexOptionFullScanResponseKeychainKind;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ArcMutexOptionFullScanResponseKeychainKindPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EnvoyAccount;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EnvoyAccount;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EnvoyAccountPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountApplyUpdate(
      {required EnvoyAccount that,
      required ArcMutexOptionFullScanResponseKeychainKind scanRequest}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
            scanRequest, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountApplyUpdateConstMeta,
      argValues: [that, scanRequest],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountApplyUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_apply_update",
        argNames: ["that", "scanRequest"],
      );

  @override
  ArcMutexNgAccountConnection
      crateApiEnvoyWalletEnvoyAccountAutoAccessorGetNgAccount(
          {required EnvoyAccount that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountAutoAccessorGetNgAccountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountAutoAccessorGetNgAccountConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccount_auto_accessor_get_ng_account",
            argNames: ["that"],
          );

  @override
  void crateApiEnvoyWalletEnvoyAccountAutoAccessorSetNgAccount(
      {required EnvoyAccount that,
      required ArcMutexNgAccountConnection ngAccount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
            ngAccount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiEnvoyWalletEnvoyAccountAutoAccessorSetNgAccountConstMeta,
      argValues: [that, ngAccount],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountAutoAccessorSetNgAccountConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccount_auto_accessor_set_ng_account",
            argNames: ["that", "ngAccount"],
          );

  @override
  BigInt crateApiEnvoyWalletEnvoyAccountBalance({required EnvoyAccount that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountBalanceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountBalanceConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_balance",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiEnvoyWalletEnvoyAccountBroadcast(
      {required EnvoyAccount that,
      required String psbt,
      required String electrumServer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_String(psbt, serializer);
        sse_encode_String(electrumServer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountBroadcastConstMeta,
      argValues: [that, psbt, electrumServer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountBroadcastConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_broadcast",
        argNames: ["that", "psbt", "electrumServer"],
      );

  @override
  NgAccountConfig crateApiEnvoyWalletEnvoyAccountConfig(
      {required EnvoyAccount that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ng_account_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountConfigConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountConfigConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_config",
        argNames: ["that"],
      );

  @override
  bool crateApiEnvoyWalletEnvoyAccountIsHot({required EnvoyAccount that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountIsHotConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountIsHotConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_is_hot",
        argNames: ["that"],
      );

  @override
  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountMigrate(
      {required String name,
      required String id,
      String? deviceSerial,
      String? dateAdded,
      required AddressType addressType,
      required String color,
      required int index,
      required String internalDescriptor,
      required String externalDescriptor,
      required String dbPath,
      required String sledDbPath,
      required Network network}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_String(id, serializer);
        sse_encode_opt_String(deviceSerial, serializer);
        sse_encode_opt_String(dateAdded, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_String(color, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_String(internalDescriptor, serializer);
        sse_encode_String(externalDescriptor, serializer);
        sse_encode_String(dbPath, serializer);
        sse_encode_String(sledDbPath, serializer);
        sse_encode_network(network, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountMigrateConstMeta,
      argValues: [
        name,
        id,
        deviceSerial,
        dateAdded,
        addressType,
        color,
        index,
        internalDescriptor,
        externalDescriptor,
        dbPath,
        sledDbPath,
        network
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountMigrateConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_migrate",
        argNames: [
          "name",
          "id",
          "deviceSerial",
          "dateAdded",
          "addressType",
          "color",
          "index",
          "internalDescriptor",
          "externalDescriptor",
          "dbPath",
          "sledDbPath",
          "network"
        ],
      );

  @override
  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountNewFromDescriptor(
      {required String name,
      String? deviceSerial,
      String? dateAdded,
      required AddressType addressType,
      required String color,
      required int index,
      required String internalDescriptor,
      required String externalDescriptor,
      required String dbPath,
      required Network network,
      required String id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_opt_String(deviceSerial, serializer);
        sse_encode_opt_String(dateAdded, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_String(color, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_String(internalDescriptor, serializer);
        sse_encode_String(externalDescriptor, serializer);
        sse_encode_String(dbPath, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountNewFromDescriptorConstMeta,
      argValues: [
        name,
        deviceSerial,
        dateAdded,
        addressType,
        color,
        index,
        internalDescriptor,
        externalDescriptor,
        dbPath,
        network,
        id
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiEnvoyWalletEnvoyAccountNewFromDescriptorConstMeta =>
          const TaskConstMeta(
            debugName: "EnvoyAccount_new_from_descriptor",
            argNames: [
              "name",
              "deviceSerial",
              "dateAdded",
              "addressType",
              "color",
              "index",
              "internalDescriptor",
              "externalDescriptor",
              "dbPath",
              "network",
              "id"
            ],
          );

  @override
  Future<String> crateApiEnvoyWalletEnvoyAccountNextAddress(
      {required EnvoyAccount that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountNextAddressConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountNextAddressConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_next_address",
        argNames: ["that"],
      );

  @override
  Future<EnvoyAccount> crateApiEnvoyWalletEnvoyAccountOpenWallet(
      {required String dbPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dbPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountOpenWalletConstMeta,
      argValues: [dbPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountOpenWalletConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_open_wallet",
        argNames: ["dbPath"],
      );

  @override
  Future<ArcMutexOptionFullScanRequestKeychainKind>
      crateApiEnvoyWalletEnvoyAccountRequestScan({required EnvoyAccount that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountRequestScanConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountRequestScanConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_request_scan",
        argNames: ["that"],
      );

  @override
  Future<ArcMutexOptionFullScanResponseKeychainKind>
      crateApiEnvoyWalletEnvoyAccountScan(
          {required ArcMutexOptionFullScanRequestKeychainKind scanRequest,
          required String electrumServer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
            scanRequest, serializer);
        sse_encode_String(electrumServer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountScanConstMeta,
      argValues: [scanRequest, electrumServer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountScanConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_scan",
        argNames: ["scanRequest", "electrumServer"],
      );

  @override
  Future<String> crateApiEnvoyWalletEnvoyAccountSend(
      {required EnvoyAccount that,
      required String address,
      required BigInt amount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_String(address, serializer);
        sse_encode_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountSendConstMeta,
      argValues: [that, address, amount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountSendConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_send",
        argNames: ["that", "address", "amount"],
      );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountSetDoNotSpend(
      {required EnvoyAccount that,
      required Output utxo,
      required bool doNotSpend}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_box_autoadd_output(utxo, serializer);
        sse_encode_bool(doNotSpend, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountSetDoNotSpendConstMeta,
      argValues: [that, utxo, doNotSpend],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountSetDoNotSpendConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_set_do_not_spend",
        argNames: ["that", "utxo", "doNotSpend"],
      );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountSetNote(
      {required EnvoyAccount that,
      required String txId,
      required String note}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_String(txId, serializer);
        sse_encode_String(note, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountSetNoteConstMeta,
      argValues: [that, txId, note],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountSetNoteConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_set_note",
        argNames: ["that", "txId", "note"],
      );

  @override
  Future<bool> crateApiEnvoyWalletEnvoyAccountSetTag(
      {required EnvoyAccount that, required Output utxo, required String tag}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        sse_encode_box_autoadd_output(utxo, serializer);
        sse_encode_String(tag, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountSetTagConstMeta,
      argValues: [that, utxo, tag],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountSetTagConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_set_tag",
        argNames: ["that", "utxo", "tag"],
      );

  @override
  Future<List<BitcoinTransaction>> crateApiEnvoyWalletEnvoyAccountTransactions(
      {required EnvoyAccount that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_bitcoin_transaction,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountTransactionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountTransactionsConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_transactions",
        argNames: ["that"],
      );

  @override
  Future<List<Output>> crateApiEnvoyWalletEnvoyAccountUtxo(
      {required EnvoyAccount that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_output,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletEnvoyAccountUtxoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletEnvoyAccountUtxoConstMeta =>
      const TaskConstMeta(
        debugName: "EnvoyAccount_utxo",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiEnvoyWalletInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiEnvoyWalletInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiEnvoyWalletInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<NgAccountConfig> ngwalletConfigNgAccountConfigDeserialize(
      {required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ng_account_config,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigDeserializeConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigDeserializeConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_deserialize",
        argNames: ["data"],
      );

  @override
  Future<bool> ngwalletConfigNgAccountConfigIsHot(
      {required NgAccountConfig that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ng_account_config(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigIsHotConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigIsHotConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_is_hot",
        argNames: ["that"],
      );

  @override
  Future<NgAccountConfig> ngwalletConfigNgAccountConfigNew(
      {required String name,
      required String color,
      String? deviceSerial,
      String? dateAdded,
      required int index,
      required String internalDescriptor,
      String? externalDescriptor,
      required AddressType addressType,
      required Network network,
      required String id,
      String? dateSynced}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        sse_encode_String(color, serializer);
        sse_encode_opt_String(deviceSerial, serializer);
        sse_encode_opt_String(dateAdded, serializer);
        sse_encode_u_32(index, serializer);
        sse_encode_String(internalDescriptor, serializer);
        sse_encode_opt_String(externalDescriptor, serializer);
        sse_encode_address_type(addressType, serializer);
        sse_encode_network(network, serializer);
        sse_encode_String(id, serializer);
        sse_encode_opt_String(dateSynced, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_ng_account_config,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigNewConstMeta,
      argValues: [
        name,
        color,
        deviceSerial,
        dateAdded,
        index,
        internalDescriptor,
        externalDescriptor,
        addressType,
        network,
        id,
        dateSynced
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigNewConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_new",
        argNames: [
          "name",
          "color",
          "deviceSerial",
          "dateAdded",
          "index",
          "internalDescriptor",
          "externalDescriptor",
          "addressType",
          "network",
          "id",
          "dateSynced"
        ],
      );

  @override
  Future<String> ngwalletConfigNgAccountConfigSerialize(
      {required NgAccountConfig that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_ng_account_config(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kNgwalletConfigNgAccountConfigSerializeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kNgwalletConfigNgAccountConfigSerializeConstMeta =>
      const TaskConstMeta(
        debugName: "ng_account_config_serialize",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexNgAccountConnection => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexNgAccountConnection => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexOptionFullScanRequestKeychainKind =>
          wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexOptionFullScanRequestKeychainKind =>
          wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcMutexOptionFullScanResponseKeychainKind =>
          wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcMutexOptionFullScanResponseKeychainKind =>
          wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EnvoyAccount => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EnvoyAccount => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ArcMutexNgAccountConnection
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  ArcMutexOptionFullScanRequestKeychainKind
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexOptionFullScanRequestKeychainKindImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  ArcMutexOptionFullScanResponseKeychainKind
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexOptionFullScanResponseKeychainKindImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  EnvoyAccount
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EnvoyAccount
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EnvoyAccount
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcMutexNgAccountConnection
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  ArcMutexOptionFullScanRequestKeychainKind
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexOptionFullScanRequestKeychainKindImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  ArcMutexOptionFullScanResponseKeychainKind
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcMutexOptionFullScanResponseKeychainKindImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  EnvoyAccount
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AddressType dco_decode_address_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AddressType.values[raw as int];
  }

  @protected
  BitcoinTransaction dco_decode_bitcoin_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return BitcoinTransaction(
      txId: dco_decode_String(arr[0]),
      blockHeight: dco_decode_u_32(arr[1]),
      confirmations: dco_decode_u_32(arr[2]),
      fee: dco_decode_u_64(arr[3]),
      amount: dco_decode_u_64(arr[4]),
      inputs: dco_decode_list_input(arr[5]),
      outputs: dco_decode_list_output(arr[6]),
      note: dco_decode_opt_String(arr[7]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  NgAccountConfig dco_decode_box_autoadd_ng_account_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ng_account_config(raw);
  }

  @protected
  Output dco_decode_box_autoadd_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_output(raw);
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Input dco_decode_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Input(
      txId: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  List<BitcoinTransaction> dco_decode_list_bitcoin_transaction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_bitcoin_transaction).toList();
  }

  @protected
  List<Input> dco_decode_list_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_input).toList();
  }

  @protected
  List<Output> dco_decode_list_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_output).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NgAccountConfig dco_decode_ng_account_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return NgAccountConfig(
      name: dco_decode_String(arr[0]),
      color: dco_decode_String(arr[1]),
      deviceSerial: dco_decode_opt_String(arr[2]),
      dateAdded: dco_decode_opt_String(arr[3]),
      addressType: dco_decode_address_type(arr[4]),
      index: dco_decode_u_32(arr[5]),
      internalDescriptor: dco_decode_String(arr[6]),
      externalDescriptor: dco_decode_opt_String(arr[7]),
      dateSynced: dco_decode_opt_String(arr[8]),
      network: dco_decode_network(arr[9]),
      id: dco_decode_String(arr[10]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  Output dco_decode_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Output(
      txId: dco_decode_String(arr[0]),
      vout: dco_decode_u_32(arr[1]),
      amount: dco_decode_u_64(arr[2]),
      tag: dco_decode_opt_String(arr[3]),
      doNotSpend: dco_decode_opt_box_autoadd_bool(arr[4]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ArcMutexNgAccountConnection
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcMutexOptionFullScanRequestKeychainKind
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexOptionFullScanRequestKeychainKindImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcMutexOptionFullScanResponseKeychainKind
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexOptionFullScanResponseKeychainKindImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccount
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccount
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccount
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcMutexNgAccountConnection
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexNgAccountConnectionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcMutexOptionFullScanRequestKeychainKind
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexOptionFullScanRequestKeychainKindImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcMutexOptionFullScanResponseKeychainKind
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcMutexOptionFullScanResponseKeychainKindImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EnvoyAccount
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EnvoyAccountImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AddressType sse_decode_address_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AddressType.values[inner];
  }

  @protected
  BitcoinTransaction sse_decode_bitcoin_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_blockHeight = sse_decode_u_32(deserializer);
    var var_confirmations = sse_decode_u_32(deserializer);
    var var_fee = sse_decode_u_64(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_inputs = sse_decode_list_input(deserializer);
    var var_outputs = sse_decode_list_output(deserializer);
    var var_note = sse_decode_opt_String(deserializer);
    return BitcoinTransaction(
        txId: var_txId,
        blockHeight: var_blockHeight,
        confirmations: var_confirmations,
        fee: var_fee,
        amount: var_amount,
        inputs: var_inputs,
        outputs: var_outputs,
        note: var_note);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  NgAccountConfig sse_decode_box_autoadd_ng_account_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ng_account_config(deserializer));
  }

  @protected
  Output sse_decode_box_autoadd_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_output(deserializer));
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  Input sse_decode_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return Input(txId: var_txId, vout: var_vout);
  }

  @protected
  List<BitcoinTransaction> sse_decode_list_bitcoin_transaction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BitcoinTransaction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bitcoin_transaction(deserializer));
    }
    return ans_;
  }

  @protected
  List<Input> sse_decode_list_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Input>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_input(deserializer));
    }
    return ans_;
  }

  @protected
  List<Output> sse_decode_list_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Output>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_output(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NgAccountConfig sse_decode_ng_account_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_color = sse_decode_String(deserializer);
    var var_deviceSerial = sse_decode_opt_String(deserializer);
    var var_dateAdded = sse_decode_opt_String(deserializer);
    var var_addressType = sse_decode_address_type(deserializer);
    var var_index = sse_decode_u_32(deserializer);
    var var_internalDescriptor = sse_decode_String(deserializer);
    var var_externalDescriptor = sse_decode_opt_String(deserializer);
    var var_dateSynced = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_id = sse_decode_String(deserializer);
    return NgAccountConfig(
        name: var_name,
        color: var_color,
        deviceSerial: var_deviceSerial,
        dateAdded: var_dateAdded,
        addressType: var_addressType,
        index: var_index,
        internalDescriptor: var_internalDescriptor,
        externalDescriptor: var_externalDescriptor,
        dateSynced: var_dateSynced,
        network: var_network,
        id: var_id);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Output sse_decode_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txId = sse_decode_String(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_tag = sse_decode_opt_String(deserializer);
    var var_doNotSpend = sse_decode_opt_box_autoadd_bool(deserializer);
    return Output(
        txId: var_txId,
        vout: var_vout,
        amount: var_amount,
        tag: var_tag,
        doNotSpend: var_doNotSpend);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          ArcMutexNgAccountConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexNgAccountConnectionImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          ArcMutexOptionFullScanRequestKeychainKind self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexOptionFullScanRequestKeychainKindImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
          ArcMutexOptionFullScanResponseKeychainKind self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexOptionFullScanResponseKeychainKindImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          EnvoyAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          EnvoyAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          EnvoyAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexNgAccountConnection(
          ArcMutexNgAccountConnection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexNgAccountConnectionImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanRequestKeychainKind(
          ArcMutexOptionFullScanRequestKeychainKind self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexOptionFullScanRequestKeychainKindImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcMutexOptionFullScanResponseKeychainKind(
          ArcMutexOptionFullScanResponseKeychainKind self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcMutexOptionFullScanResponseKeychainKindImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEnvoyAccount(
          EnvoyAccount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as EnvoyAccountImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address_type(AddressType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bitcoin_transaction(
      BitcoinTransaction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_u_32(self.blockHeight, serializer);
    sse_encode_u_32(self.confirmations, serializer);
    sse_encode_u_64(self.fee, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_list_input(self.inputs, serializer);
    sse_encode_list_output(self.outputs, serializer);
    sse_encode_opt_String(self.note, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ng_account_config(
      NgAccountConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ng_account_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_output(Output self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_output(self, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_input(Input self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_list_bitcoin_transaction(
      List<BitcoinTransaction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bitcoin_transaction(item, serializer);
    }
  }

  @protected
  void sse_encode_list_input(List<Input> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_input(item, serializer);
    }
  }

  @protected
  void sse_encode_list_output(List<Output> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_output(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ng_account_config(
      NgAccountConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.color, serializer);
    sse_encode_opt_String(self.deviceSerial, serializer);
    sse_encode_opt_String(self.dateAdded, serializer);
    sse_encode_address_type(self.addressType, serializer);
    sse_encode_u_32(self.index, serializer);
    sse_encode_String(self.internalDescriptor, serializer);
    sse_encode_opt_String(self.externalDescriptor, serializer);
    sse_encode_opt_String(self.dateSynced, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_String(self.id, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_output(Output self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.txId, serializer);
    sse_encode_u_32(self.vout, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_opt_String(self.tag, serializer);
    sse_encode_opt_box_autoadd_bool(self.doNotSpend, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class ArcMutexNgAccountConnectionImpl extends RustOpaque
    implements ArcMutexNgAccountConnection {
  // Not to be used by end users
  ArcMutexNgAccountConnectionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcMutexNgAccountConnectionImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_ArcMutexNgAccountConnection,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexNgAccountConnection,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexNgAccountConnectionPtr,
  );
}

@sealed
class ArcMutexOptionFullScanRequestKeychainKindImpl extends RustOpaque
    implements ArcMutexOptionFullScanRequestKeychainKind {
  // Not to be used by end users
  ArcMutexOptionFullScanRequestKeychainKindImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcMutexOptionFullScanRequestKeychainKindImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_ArcMutexOptionFullScanRequestKeychainKind,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexOptionFullScanRequestKeychainKind,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexOptionFullScanRequestKeychainKindPtr,
  );
}

@sealed
class ArcMutexOptionFullScanResponseKeychainKindImpl extends RustOpaque
    implements ArcMutexOptionFullScanResponseKeychainKind {
  // Not to be used by end users
  ArcMutexOptionFullScanResponseKeychainKindImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcMutexOptionFullScanResponseKeychainKindImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_ArcMutexOptionFullScanResponseKeychainKind,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexOptionFullScanResponseKeychainKind,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcMutexOptionFullScanResponseKeychainKindPtr,
  );
}

@sealed
class EnvoyAccountImpl extends RustOpaque implements EnvoyAccount {
  // Not to be used by end users
  EnvoyAccountImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  EnvoyAccountImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_EnvoyAccount,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_EnvoyAccount,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_EnvoyAccountPtr,
  );

  Future<bool> applyUpdate(
          {required ArcMutexOptionFullScanResponseKeychainKind scanRequest}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountApplyUpdate(
          that: this, scanRequest: scanRequest);

  ArcMutexNgAccountConnection get ngAccount => RustLib.instance.api
          .crateApiEnvoyWalletEnvoyAccountAutoAccessorGetNgAccount(
        that: this,
      );

  set ngAccount(ArcMutexNgAccountConnection ngAccount) => RustLib.instance.api
      .crateApiEnvoyWalletEnvoyAccountAutoAccessorSetNgAccount(
          that: this, ngAccount: ngAccount);

  BigInt balance() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountBalance(
        that: this,
      );

  Future<void> broadcast(
          {required String psbt, required String electrumServer}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountBroadcast(
          that: this, psbt: psbt, electrumServer: electrumServer);

  NgAccountConfig config() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountConfig(
        that: this,
      );

  bool isHot() => RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountIsHot(
        that: this,
      );

  Future<String> nextAddress() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountNextAddress(
        that: this,
      );

  Future<ArcMutexOptionFullScanRequestKeychainKind> requestScan() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountRequestScan(
        that: this,
      );

  Future<String> send({required String address, required BigInt amount}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountSend(
          that: this, address: address, amount: amount);

  Future<bool> setDoNotSpend(
          {required Output utxo, required bool doNotSpend}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountSetDoNotSpend(
          that: this, utxo: utxo, doNotSpend: doNotSpend);

  Future<bool> setNote({required String txId, required String note}) =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountSetNote(
          that: this, txId: txId, note: note);

  Future<bool> setTag({required Output utxo, required String tag}) => RustLib
      .instance.api
      .crateApiEnvoyWalletEnvoyAccountSetTag(that: this, utxo: utxo, tag: tag);

  Future<List<BitcoinTransaction>> transactions() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountTransactions(
        that: this,
      );

  Future<List<Output>> utxo() =>
      RustLib.instance.api.crateApiEnvoyWalletEnvoyAccountUtxo(
        that: this,
      );
}
